#!/bin/sh

#############################################################################
# Version 1.5.0-RELEASE (28-01-2023)
#############################################################################

#############################################################################
# Copyright 2016-2023 Nozel/Sebas Veeke. Licenced under a Creative Commons
# Attribution-NonCommercial-ShareAlike 4.0 International License.
#
# See https://creativecommons.org/licenses/by-nc-sa/4.0/
#
# Contact:
# > e-mail      mail@nozel.org
# > GitHub      nozel-org
#############################################################################

#############################################################################
# VARIABLES
#############################################################################

# serverbot version
SERVERBOT_VERSION='1.5.0'

# commands
CURL="$(command -v curl)"

# colors
NC='\033[0;0m'
BOLD='\033[1m'
#UNDER='\033[4m'
#WHITE='\033[1;37m'
#RED='\033[0;31m'
#GREEN='\033[0;32m'
YELLOW='\033[1;33m'
LRED='\033[1;31m'
#LGREEN='\033[1;32m'
#LMAGENTA='\033[1;35m'
#LCYAN='\033[1;36m'

# check whether serverbot.conf is available and source it
if [ -f /usr/local/etc/serverbot.conf ]; then
    # populate all usable variables to have defaults and check validity later on
    SMT_ENABLE='0'
    LOAD_INTERVAL='0'
    ZFS_ENABLE='0'
    THRESHOLD_LOAD='0'
    THRESHOLD_MEMORY='0'
    THRESHOLD_DISK='0'
    SUMMARY_TELEGRAM='0'
    OVERVIEW_TELEGRAM='0'
    ALERT_TELEGRAM='0'
    TELEGRAM_TOKEN='0'
    TELEGRAM_CHAT='0'

    # and source backupbot.conf
    . /usr/local/etc/serverbot.conf

    if [ "${SMT_ENABLE}" = 'yes' ] || [ "${SMT_ENABLE}" = 'YES' ]; then
        CONFIG_SMT_ENABLE='1'
    else
        CONFIG_SMT_ENABLE='0'
    fi
    if [ "${LOAD_INTERVAL}" = '1' ]; then
        CONFIG_LOAD_INTERVAL='1'
    elif [ "${LOAD_INTERVAL}" = '5' ]; then
        CONFIG_LOAD_INTERVAL='5'
    elif [ "${LOAD_INTERVAL}" = '15' ]; then
        CONFIG_LOAD_INTERVAL='15'
    else
        CONFIG_LOAD_INTERVAL='15'
    fi
    if [ "${ZFS_ENABLE}" = 'yes' ] || [ "${ZFS_ENABLE}" = 'YES' ]; then
        CONFIG_ZFS_ENABLE='1'
    else
        CONFIG_ZFS_ENABLE='0'
    fi
    if [ "${THRESHOLD_LOAD}" -lt '0' ]; then
        CONFIG_THRESHOLD_LOAD='95'
    elif [ "${THRESHOLD_LOAD}" -ge '0' ]; then
        CONFIG_THRESHOLD_LOAD="${THRESHOLD_LOAD}"
    fi
    if [ "${THRESHOLD_MEMORY}" -lt '0' ] || [ "${THRESHOLD_MEMORY}" -gt '100' ]; then
        CONFIG_THRESHOLD_MEMORY='90'
    elif [ "${THRESHOLD_MEMORY}" -ge '0' ] || [ "${THRESHOLD_MEMORY}" -le '100' ]; then
        CONFIG_THRESHOLD_MEMORY="${THRESHOLD_MEMORY}"
    fi
    if [ "${THRESHOLD_DISK}" -lt '0' ] || [ "${THRESHOLD_DISK}" -gt '100' ]; then
        CONFIG_THRESHOLD_DISK='80'
    elif [ "${THRESHOLD_DISK}" -ge '0' ] && [ "${THRESHOLD_DISK}" -le '100' ]; then
        CONFIG_THRESHOLD_DISK="${THRESHOLD_DISK}"
    fi
    if [ "${SUMMARY_TELEGRAM}" = 'yes' ] || [ "${SUMMARY_TELEGRAM}" = 'YES' ]; then
        CONFIG_SUMMARY_TELEGRAM='1'
    else
        CONFIG_SUMMARY_TELEGRAM='0'
    fi
    if [ "${OVERVIEW_TELEGRAM}" = 'yes' ] || [ "${OVERVIEW_TELEGRAM}" = 'YES' ]; then
        CONFIG_OVERVIEW_TELEGRAM='1'
    else
        CONFIG_OVERVIEW_TELEGRAM='0'
    fi
    if [ "${ALERT_TELEGRAM}" = 'yes' ] || [ "${ALERT_TELEGRAM}" = 'YES' ]; then
        CONFIG_ALERT_TELEGRAM='1'
    else
        CONFIG_ALERT_TELEGRAM='0'
    fi
    if [ "${TELEGRAM_TOKEN}" = '0' ] || [ "${TELEGRAM_CHAT}" = '0' ]; then
        METHOD_TELEGRAM='0'
    else
        METHOD_TELEGRAM='1'
    fi
else
    CONFIG_SMT_ENABLE='0'
    CONFIG_LOAD_INTERVAL='15'
    CONFIG_ZFS_ENABLE='0'
    CONFIG_THRESHOLD_LOAD='95'
    CONFIG_THRESHOLD_MEMORY='90'
    CONFIG_THRESHOLD_DISK='80'
    CONFIG_SUMMARY_TELEGRAM='0'
    CONFIG_OVERVIEW_TELEGRAM='0'
    CONFIG_ALERT_TELEGRAM='0'
fi

####################################################################################################
# ARGUMENT HANDLING
####################################################################################################

# populate validation variables with zeros for validation
ARGUMENT_OPTION='0'
ARGUMENT_VERSION='0'
ARGUMENT_HELP='0'
ARGUMENT_FEATURE='0'
ARGUMENT_SERVER='0'
ARGUMENT_UPTIME='0'
ARGUMENT_MEMORY='0'
ARGUMENT_MEMORYTREE='0'
ARGUMENT_DISK='0'
ARGUMENT_NETWORK='0'
ARGUMENT_SUMMARY='0'
ARGUMENT_OVERVIEW='0'
ARGUMENT_METHOD='0'
ARGUMENT_CLI='0'
ARGUMENT_TELEGRAM='0'

# read arguments
while test -n "$1"; do
    case "$1" in
        # options
        --version|-version|version|--v|-v)
            ARGUMENT_VERSION='1'
            ARGUMENT_OPTION='1'
            shift
            ;;

        --help|-help|help|--h|-h)
            ARGUMENT_HELP='1'
            ARGUMENT_OPTION='1'
            shift
            ;;
        
        --cron|-cron|cron)
            ARGUMENT_CRON='1'
            ARGUMENT_OPTION='1'
            shift
            ;;

        # features
        --server|server|-s)
            ARGUMENT_SERVER='1'
            ARGUMENT_FEATURE='1'
            shift
            ;;

        --summary|summary|-S)
            ARGUMENT_SUMMARY='1'
            ARGUMENT_FEATURE='1'
            shift
            ;;

        --overview|overview|-o)
            ARGUMENT_OVERVIEW='1'
            ARGUMENT_FEATURE='1'
            shift
            ;;

        --uptime|uptime|-u)
            ARGUMENT_UPTIME='1'
            ARGUMENT_FEATURE='1'
            shift
            ;;

        --cpu|cpu|processor|-C)
            ARGUMENT_CPU='1'
            ARGUMENT_FEATURE='1'
            shift
            ;;

        --memory|memory|ram|-m)
            ARGUMENT_MEMORY='1'
            ARGUMENT_FEATURE='1'
            shift
            ;;

        --memorytree|memorytree|-M)
            ARGUMENT_MEMORYTREE='1'
            ARGUMENT_FEATURE='1'
            shift
            ;;

        --disk|disk|hdd|ssd|-d)
            ARGUMENT_DISK='1'
            ARGUMENT_FEATURE='1'
            shift
            ;;

        --network|network|-n)
            ARGUMENT_NETWORK='1'
            ARGUMENT_FEATURE='1'
            shift
            ;;

        --alert|alert|-a)
            ARGUMENT_ALERT='1'
            ARGUMENT_FEATURE='1'
            shift
            ;;

        # methods
        --cli|cli|-c)
            ARGUMENT_CLI='1'
            ARGUMENT_METHOD='1'
            shift
            ;;

        --telegram|telegram|-t)
            ARGUMENT_TELEGRAM='1'
            ARGUMENT_METHOD='1'
            shift
            ;;

        # other
        *)
            ARGUMENT_NONE='1'
            shift
            ;;
    esac
done


####################################################################################################
# ERROR FUNCTIONS
####################################################################################################

error_no_root_privileges() {
    printf 'serverbot: error: used argument must be run with root privileges.\n'
    exit 1
}

error_os_not_supported() {
    printf 'serverbot: operating system is not supported.\n'
    exit 1
}

error_curl_not_installed() {
    printf 'serverbot: curl is not installed.\n'
    exit 1
}

error_invalid_argument() {
    printf "serverbot: invalid argument used.\nUse 'serverbot --help' for a list of valid arguments.\n"
    exit 1
}
error_more_than_one_feature() {
    printf "serverbot: only one serverbot feature can be used at a time.\nUse 'serverbot --help' for a list of valid arguments.\n"
    exit 1
}

error_more_than_one_method() {
    printf "serverbot: only one serverbot method can be used at a time.\nUse 'serverbot --help' for a list of valid arguments.\n"
    exit 1
}

error_method_not_supported() {
    printf "serverbot: the chosen method isn't supported for the chosen feature.\n"
    exit 1
}

####################################################################################################
# REQUIREMENT AND VALIDATION FUNCTIONS
####################################################################################################

requirement_root() {
    # show error when updatebot isn't run with root privileges
    if [ "$(id -u)" -ne '0' ]; then
        error_no_root_privileges
    fi
}

requirement_os() {
    # show error when freebsd-version cannot be found
    if [ ! "$(command -v freebsd-version)" ]; then
        error_os_not_supported
    fi
}

requirement_curl() {
    # show error when curl cannot be found (which probably means the user has not installed curl)
    if [ ! "$(command -v curl)" ]; then
        error_curl_not_installed
    fi
}

serverbot_argument_validate() {
    # combine argument categories
    ARGUMENT_FEATURES_COMBINED="$((ARGUMENT_SERVER + ARGUMENT_SUMMARY + ARGUMENT_OVERVIEW + ARGUMENT_UPTIME + ARGUMENT_CPU + ARGUMENT_MEMORY + ARGUMENT_MEMORYTREE + ARGUMENT_DISK + ARGUMENT_NETWORK + ARGUMENT_ALERT))"
    ARGUMENT_METHOD_COMBINED="$((ARGUMENT_CLI + ARGUMENT_TELEGRAM))"

    if [ "${ARGUMENT_NONE}" = '1' ]; then
        error_invalid_argument
    # validate amount of selected features and return error when more than 1 feature is selected
    elif [ "${ARGUMENT_FEATURES_COMBINED}" -gt '1' ]; then
        error_more_than_one_feature
    # validate amount of selected methods and return error when more than 1 feature is selected
    elif [ "${ARGUMENT_METHOD_COMBINED}" -gt '1' ]; then
        error_more_than_one_method
    fi
}

####################################################################################################
# GENERAL FUNCTIONS
####################################################################################################

option_version() {
    printf "%bServerbot %s %b\n" "${BOLD}" "${SERVERBOT_VERSION}" "${NC}"
    printf "%bCopyright (C) 2016-2023 Nozel.%b\n" "${BOLD}" "${NC}"
    printf "%bLicense CC Attribution-NonCommercial-ShareAlike 4.0 Int.%b\n\n" "${BOLD}" "${NC}"
    printf "%bWritten by Sebas Veeke%b\n" "${BOLD}" "${NC}"

    # exit when done
    exit 0
}

option_help() {
    printf "%bUsage:%b\n" "${BOLD}" "${NC}"
    printf "%b  serverbot [feature]... [method]...%b\n" "${BOLD}" "${NC}"
    printf "%b  serverbot [option]...%b\n\n" "${BOLD}" "${NC}"
    printf "%bFeatures:%b\n" "${BOLD}" "${NC}"
    printf "  -s, --server               Basic server information\n"
    printf "  -S, --summary              Server overview\n"
    printf "  -o, --overview             Extended server overview\n"
    printf "  -u, --uptime               Server uptime metrics\n"
    printf "  -C, --cpu                  CPU load metrics\n"
    printf "  -m, --memory               Basic memory usage metrics\n"
    printf "  -M, --memorytree           Extended memory usage metrics\n"
    printf "  -d, --disk                 Disk usage metrics\n"
    printf "  -n, --network              Interfaces and IP addresses\n"
    printf "  -a, --alert                Alerts when metric thresholds are reached\n\n"
    printf "%bMethods:%b\n" "${BOLD}" "${NC}"
    printf "  -c, --cli (default)        Output [feature] to command line\n"
    printf "  -t, --telegram             Output [feature] to Telegram\n\n"
    printf "%bOptions:%b\n" "${BOLD}" "${NC}"
    printf "  --cron                     Effectuate cron changes from serverbot config\n"
    printf "  --help                     Display this help and exit\n"
    printf "  --version                  Display version information and exit\n"

    # exit when done
    exit 0
}

option_cron() {
    requirement_root

    printf "%b[1] Removing old serverbot cronjob%b\n" "${BOLD}" "${NC}"
    rm -f /etc/cron.d/serverbot
    if [ "${CONFIG_SUMMARY_TELEGRAM}" = '0' ] && [ "${CONFIG_OVERVIEW_TELEGRAM}" = '0' ] && [ "${CONFIG_ALERT_TELEGRAM}" = '0' ]; then
        printf "%b[2] No automated tasks to add.%b\n\n" "${BOLD}" "${NC}"
        printf "%bAll done!%b\n" "${BOLD}" "${NC}"
    else
        printf "%b[2] Adding configured automated tasks for:%b\n" "${BOLD}" "${NC}"
        printf "# This cronjob manages automated serverbot features\n" > /etc/cron.d/serverbot
        if [ "${CONFIG_SUMMARY_TELEGRAM}" = '1' ]; then
            printf "    - Summary Feature on cron schedule %s\n" "${SUMMARY_CRON}"
            printf "${SUMMARY_CRON} root /usr/local/bin/serverbot --summary --telegram\n" >> /etc/cron.d/serverbot
        fi
        if [ "${CONFIG_OVERVIEW_TELEGRAM}" = '1' ]; then
            printf "    - Overview Feature on cron schedule %s\n" "${OVERVIEW_CRON}"
            printf "${OVERVIEW_CRON} root /usr/local/bin/serverbot --overview --telegram\n" >> /etc/cron.d/serverbot
        fi
        if [ "${CONFIG_ALERT_TELEGRAM}" = '1' ]; then
            printf "    - Alert Feature on cron schedule %s\n" "${ALERT_CRON}"
            printf "${ALERT_CRON} root /usr/local/bin/serverbot --alert --telegram\n" >> /etc/cron.d/serverbot
        fi
        printf "%b[3] Changing cronjob owner and group to root:wheel%b\n" "${BOLD}" "${NC}"
        chown root:wheel /etc/cron.d/serverbot
        printf "\n%bAll done! Your new schedule can be found in /etc/cron.d/serverbot.%b\n" "${BOLD}" "${NC}"
    fi

    # exit when done
    exit 0
}

####################################################################################################
# CONVERT FUNCTIONS
####################################################################################################

convert_bytes_to_human_readable_memory() {
    # this function converts $1 (amount of bytes) to a human readable format based on lower and upper limits
    MEMORY_B_LOW='1'                      # byte lower limit is '1', otherwise report '0'
    MEMORY_B_HIGH='9999'                  # byte upper limit is '9.999' bytes
    MEMORY_KB_LOW='10000'                 # kilobytes will be used starting at 10 kilobytes
    MEMORY_KB_HIGH='9999999'              # kilobytes upper limit is '999.999' bytes
    MEMORY_MB_LOW='10000000'              # megabytes will be used starting at 10 megabytes
    MEMORY_MB_HIGH='9999999999'           # megabytes upper limit is '999.999.999' bytes
    MEMORY_GB_LOW='10000000000'           # gigabytes will be used starting at 10 gigabytes
    MEMORY_GB_HIGH='9999999999999'        # gigabytes upper limit is '999.999.999.999' bytes
    MEMORY_TB_LOW='10000000000000'        # terabytes will be used starting at 10 terabytes
    MEMORY_TB_HIGH='9999999999999999'     # terabytes upper limit is '999.999.999.999.999 bytes
    MEMORY_PB_LOW='10000000000000000'     # petabytes will be used starting at 10 petabytes
    MEMORY_PB_HIGH=''                     # there is no upper limit for terabytes

    # a decimal multiplier of 1000 is used for the following unit prefixes:
    # B = byte, KB = kilobyte, MB = megabyte, GB = gigabyte, TB = terabyte, PB = petabyte
    if [ "$1" -eq '0' ]; then
        MEMORY_VIEW='0 B'
    elif [ "$1" -gt "${MEMORY_B_LOW}" ] && [ "$1" -le "${MEMORY_B_HIGH}" ]; then
        MEMORY_VIEW="$1 B"
    elif [ "$1" -gt "${MEMORY_KB_LOW}" ] && [ "$1" -le "${MEMORY_KB_HIGH}" ]; then
        MEMORY_VIEW="$(($1 / 1000)) KB"
    elif [ "$1" -gt "${MEMORY_MB_LOW}" ] && [ "$1" -le "${MEMORY_MB_HIGH}" ]; then
        MEMORY_VIEW="$(($1 / (1000 * 1000))) MB"
    elif [ "$1" -gt "${MEMORY_GB_LOW}" ] && [ "$1" -le "${MEMORY_GB_HIGH}" ]; then
        MEMORY_VIEW="$(($1 / (1000 * 1000 * 1000))) GB"
    elif [ "$1" -gt "${MEMORY_TB_LOW}" ] && [ "$1" -le "${MEMORY_TB_HIGH}" ]; then
        MEMORY_VIEW="$(($1 / (1000 * 1000 * 1000 * 1000))) TB"
    elif [ "$1" -gt "${MEMORY_PB_LOW}" ]; then
        MEMORY_VIEW="$(($1 / (1000 * 1000 * 1000 * 1000 * 1000))) PB"
    fi
}

convert_bytes_to_human_readable_disk() {
    # this function converts $1 (amount of bytes) to a human readable format based on lower and upper limits
    DISK_B_LOW='1'                      # byte lower limit is '1', otherwise report '0'
    DISK_B_HIGH='9999'                  # byte upper limit is '9.999' bytes
    DISK_KB_LOW='10000'                 # kilobytes will be used starting at 10 kilobytes
    DISK_KB_HIGH='9999999'              # kilobytes upper limit is '999.999' bytes
    DISK_MB_LOW='10000000'              # megabytes will be used starting at 10 megabytes
    DISK_MB_HIGH='9999999999'           # megabytes upper limit is '999.999.999' bytes
    DISK_GB_LOW='10000000000'           # gigabytes will be used starting at 10 gigabytes
    DISK_GB_HIGH='9999999999999'        # gigabytes upper limit is '999.999.999.999' bytes
    DISK_TB_LOW='10000000000000'        # terabytes will be used starting at 10 terabytes
    DISK_TB_HIGH='9999999999999999'     # terabytes upper limit is '999.999.999.999.999 bytes
    DISK_PB_LOW='10000000000000000'     # petabytes will be used starting at 10 petabytes
    DISK_PB_HIGH=''                     # there is no upper limit for terabytes

    # a decimal multiplier of 1000 is used for the following unit prefixes:
    # B = byte, KB = kilobyte, MB = megabyte, GB = gigabyte, TB = terabyte, PB = petabyte
    if [ "$1" -eq '0' ]; then
        ROOT_PARTITION_VIEW='0 B'
    elif [ "$1" -gt "${DISK_B_LOW}" ] && [ "$1" -le "${DISK_B_HIGH}" ]; then
        ROOT_PARTITION_VIEW="$1 B"
    elif [ "$1" -gt "${DISK_KB_LOW}" ] && [ "$1" -le "${DISK_KB_HIGH}" ]; then
        ROOT_PARTITION_VIEW="$(($1 / 1000)) KB"
    elif [ "$1" -gt "${DISK_MB_LOW}" ] && [ "$1" -le "${DISK_MB_HIGH}" ]; then
        ROOT_PARTITION_VIEW="$(($1 / (1000 * 1000))) MB"
    elif [ "$1" -gt "${DISK_GB_LOW}" ] && [ "$1" -le "${DISK_GB_HIGH}" ]; then
        ROOT_PARTITION_VIEW="$(($1 / (1000 * 1000 * 1000))) GB"
    elif [ "$1" -gt "${DISK_TB_LOW}" ] && [ "$1" -le "${DISK_TB_HIGH}" ]; then
        ROOT_PARTITION_VIEW="$(($1 / (1000 * 1000 * 1000 * 1000))) TB"
    elif [ "$1" -gt "${DISK_PB_LOW}" ]; then
        ROOT_PARTITION_VIEW="$(($1 / (1000 * 1000 * 1000 * 1000 * 1000))) PB"
    fi
}

####################################################################################################
# GATHER FUNCTIONS
####################################################################################################

gather_metrics_server() {
    FREEBSD_VERSION="$(freebsd-version)"
    HOSTNAME="$(uname -n)"
    OPERATING_SYSTEM="$(uname -o)"
    #KERNEL_NAME="$(uname -s)"
    #KERNEL_VERSION="$(uname -r)"
    ARCHITECTURE="$(uname -m)"
}

gather_metrics_uptime() {
    # the freebsd uptime command is very inflexible so serverbot generates its own uptime metrics from epoch
    EPOCH_TIME="$(date +%s)"
    EPOCH_UPTIME="$(sysctl kern.boottime | awk '{printf $5}' | tr -d ',')"
    UPTIME_CALC="$((EPOCH_TIME-EPOCH_UPTIME))"
    UPTIME_DAY="$((UPTIME_CALC/86400))"
    UPTIME_DAY_ROUNDED="$((UPTIME_DAY*86400))"
    UPTIME_HOUR="$(((UPTIME_CALC-UPTIME_DAY_ROUNDED)/3600))"
    UPTIME_HOUR_ROUNDED="$((UPTIME_HOUR*3600))"
    UPTIME_MIN="$(((UPTIME_CALC-UPTIME_DAY_ROUNDED-UPTIME_HOUR_ROUNDED)/60))"
    UPTIME_MIN_ROUNDED="$((UPTIME_MIN*60))"
    UPTIME_SEC="$(((UPTIME_CALC-UPTIME_DAY_ROUNDED-UPTIME_HOUR_ROUNDED)-UPTIME_MIN_ROUNDED))"

    # determine single or plural for time units
    if [ "${UPTIME_DAY}" -ge '1' ]; then
        if [ "${UPTIME_DAY}" -eq '1' ]; then
            DAY="${UPTIME_DAY} day"
        else
            DAY="${UPTIME_DAY} days"
        fi
        if [ "${UPTIME_HOUR}" -eq '1' ]; then
            HOUR="${UPTIME_HOUR} hour"
        else
            HOUR="${UPTIME_HOUR} hours"
        fi
        if [ "${UPTIME_MIN}" -eq '1' ]; then
            MIN="${UPTIME_MIN} minute"
        else
            MIN="${UPTIME_MIN} minutes"
        fi
        if [ "${UPTIME_SEC}" -eq '1' ]; then
            SEC="${UPTIME_SEC} second"
        else
            SEC="${UPTIME_SEC} seconds"
        fi
        UPTIME_MESSAGE="${DAY} ${HOUR} ${MIN} ${SEC}"
    elif [ "${UPTIME_HOUR}" -ge '1' ]; then
        if [ "${UPTIME_HOUR}" -eq '1' ]; then
            HOUR="${UPTIME_HOUR} hour"
        else
            HOUR="${UPTIME_HOUR} hours"
        fi
        if [ "${UPTIME_MIN}" -eq '1' ]; then
            MIN="${UPTIME_MIN} minute"
        else
            MIN="${UPTIME_MIN} minutes"
        fi
        if [ "${UPTIME_SEC}" -eq '1' ]; then
            SEC="${UPTIME_SEC} second"
        else
            SEC="${UPTIME_SEC} seconds"
        fi
        UPTIME_MESSAGE="${HOUR} ${MIN} ${SEC}"
    elif [ "${UPTIME_MIN}" -ge '1' ]; then
        if [ "${UPTIME_MIN}" -eq '1' ]; then
            MIN="${UPTIME_MIN} minute"
        else
            MIN="${UPTIME_MIN} minutes"
        fi
        if [ "${UPTIME_SEC}" -eq '1' ]; then
            SEC="${UPTIME_SEC} second"
        else
            SEC="${UPTIME_SEC} seconds"
        fi
        UPTIME_MESSAGE="${MIN} ${SEC}"
    elif [ "${UPTIME_SEC}" -ge '1' ]; then
        if [ "${UPTIME_SEC}" -eq '1' ]; then
            SEC="${UPTIME_SEC} second"
        else
            SEC="${UPTIME_SEC} seconds"
        fi
        UPTIME_MESSAGE="${SEC}"
    fi
}

gather_metrics_cpu() {
    # $CPU_TOTAL_CORES is based on the number of threads available to the operating system. this
    # can be misleading since simultaneous multithreading (SMT) effectively doubles the amount of
    # threads available to the operating system, while providing only a fraction of the performance
    # of a real physical CPU core. SMT provides a efficiency boost at best, but with that in mind
    # they get saturated quite fast and that's why we can still use them. you can set $SMT_ENABLE
    # in serverbot.conf to 'yes' if you want serverbot to halve the amount of available threads.
    if [ "${CONFIG_SMT_ENABLE}" = '1' ]; then
        CPU_TOTAL_CORES="$(($(sysctl -n hw.ncpu) / 2))"
    else
        CPU_TOTAL_CORES="$(sysctl -n hw.ncpu)"
    fi
    # create variable with maximum load based on total CPU core count
    CPU_MAXIMUM_LOAD="${CPU_TOTAL_CORES}.00"
    # making calculations with the load metrics is easier this way
    CPU_MAXIMUM_LOAD_CALC="${CPU_TOTAL_CORES}00"

    # load average is calculated over respectively 1, 5 and 15 minutes. a load average of 1.00 means
    # that one CPU core is working 100% of the time. a load average of 2.00 means that two CPU cores
    # can be saturated fully. on a single core CPU, this will mean that the cpu is overloaded by 100%
    # and that processes will have to wait on each other. the practical real load of a system depends
    # on the average load and the number of cores and threads in the CPU.
    CPU_LOAD_AVERAGE_1MIN="$(sysctl -n vm.loadavg | tr -d '{}' | awk '{printf $1}')"
    CPU_LOAD_AVERAGE_5MIN="$(sysctl -n vm.loadavg | tr -d '{}' | awk '{printf $2}')"
    CPU_LOAD_AVERAGE_15MIN="$(sysctl -n vm.loadavg | tr -d '{}' | awk '{printf $3}')"
    # remove dots and one or two leading zeros from 'x.xx' load
    CPU_LOAD_AVERAGE_1MIN_CALC="$(echo "${CPU_LOAD_AVERAGE_1MIN}" | tr -d '.' | sed 's/^0//' | sed 's/^0//')"
    CPU_LOAD_AVERAGE_5MIN_CALC="$(echo "${CPU_LOAD_AVERAGE_5MIN}" | tr -d '.' | sed 's/^0//' | sed 's/^0//')"
    CPU_LOAD_AVERAGE_15MIN_CALC="$(echo "${CPU_LOAD_AVERAGE_15MIN}" | tr -d '.' | sed 's/^0//' | sed 's/^0//')"
    CPU_LOAD_PERCENTAGE_1MIN="$((100*CPU_LOAD_AVERAGE_1MIN_CALC/CPU_MAXIMUM_LOAD_CALC))"
    CPU_LOAD_PERCENTAGE_5MIN="$((100*CPU_LOAD_AVERAGE_5MIN_CALC/CPU_MAXIMUM_LOAD_CALC))"
    CPU_LOAD_PERCENTAGE_15MIN="$((100*CPU_LOAD_AVERAGE_15MIN_CALC/CPU_MAXIMUM_LOAD_CALC))"

    # one load average percentage will be used for reporting/alerting purposes. the load average interval can be
    # configured by setting the $LOAD_INTERVAL variable in serverbot.conf. '15' minutes is the default
    if [ "${CONFIG_LOAD_INTERVAL}" = '1' ]; then
        CPU_LOAD_PERCENTAGE_VIEW="${CPU_LOAD_PERCENTAGE_1MIN_VIEW}"
    elif [ "${CONFIG_LOAD_INTERVAL}" = '5' ]; then
        CPU_LOAD_PERCENTAGE_VIEW="${CPU_LOAD_PERCENTAGE_5MIN_VIEW}"
    elif [ "${CONFIG_LOAD_INTERVAL}" = '15' ]; then
        CPU_LOAD_PERCENTAGE_VIEW="${CPU_LOAD_PERCENTAGE_15MIN_VIEW}"
    else
        CPU_LOAD_PERCENTAGE_VIEW="${CPU_LOAD_PERCENTAGE_15MIN_VIEW}"
    fi
}

gather_metrics_memory() {
    # this function gathers memory metrics with a lot of help from sysctl. every $MEMORY_*_COUNT
    # consists of the amount of memory pages used. Each memory page consists of $MEMORY_PAGE_SIZE
    # amount of bytes

    # a decimal multiplier of 1000 is used for the following unit prefixes:
    # B = byte, KB = kilobyte, MB = megabyte, GB = gigabyte, TB = terabyte

    # page size: amount of memory (in bytes) reported by the firmware.
    MEMORY_PAGE_SIZE="$(sysctl -n hw.pagesize)"

    # hw.physman:  amount of physical memory (in bytes) minus kernel and pre-loaded modules
    # hw.usermem:  amount of memory (in bytes) which is not wired.
    # hw.realmem: 
    MEMORY_TOTAL_PHYSICAL_B="$(sysctl -n hw.physmem)"
    MEMORY_TOTAL_USER_B="$(sysctl -n hw.usermem)"
    MEMORY_TOTAL_REAL_B="$(sysctl -n hw.realmem)"

    # active:    contains active (recently referenced) pages
    # inactive:  contains inactive pages that are aged out of the active queue
    # laundry:   queue for managing dirty inactive pages which must be cleaned
    # wired:     non-pageable memory that cannot be freed unless released by the owner
    # free:      contains available memory for use by the system
    MEMORY_ACTIVE_COUNT="$(sysctl -n vm.stats.vm.v_active_count)"
    MEMORY_ACTIVE_B="$((MEMORY_ACTIVE_COUNT * MEMORY_PAGE_SIZE))"
    MEMORY_INACTIVE_COUNT="$(sysctl -n vm.stats.vm.v_inactive_count)"
    MEMORY_INACTIVE_B="$((MEMORY_INACTIVE_COUNT * MEMORY_PAGE_SIZE))"
    MEMORY_LAUNDRY_COUNT="$(sysctl -n vm.stats.vm.v_laundry_count)"
    MEMORY_LAUNDRY_B="$((MEMORY_LAUNDRY_COUNT * MEMORY_PAGE_SIZE))"
    MEMORY_WIRED_COUNT="$(sysctl -n vm.stats.vm.v_wire_count)"
    MEMORY_WIRED_B="$((MEMORY_WIRED_COUNT * MEMORY_PAGE_SIZE))"
    MEMORY_WIRED_ARC_B="$(sysctl -n kstat.zfs.misc.arcstats.size)"
    MEMORY_WIRED_KERNEL_B="$((MEMORY_WIRED_B - MEMORY_WIRED_ARC_B))"
    MEMORY_CACHE_COUNT="$(sysctl -n vm.stats.vm.v_cache_count)"
    MEMORY_CACHE_B="$((MEMORY_CACHE_COUNT * MEMORY_PAGE_SIZE))"
    MEMORY_FREE_COUNT="$(sysctl -n vm.stats.vm.v_free_count)"
    MEMORY_FREE_B="$((MEMORY_FREE_COUNT * MEMORY_PAGE_SIZE))"

    # used memory:        equal to active and wired memory combined
    # used noarc memory:  equal to used memory minus the zfs arc cache
    # unused memory:      equal to inactive and free memory combined
    # total memory:       equal to active, inactive, laundry, wired, cache and free memory combined
    MEMORY_USED_COUNT="$((MEMORY_ACTIVE_COUNT + MEMORY_WIRED_COUNT))"
    MEMORY_USED_B="$((MEMORY_USED_COUNT * MEMORY_PAGE_SIZE))"
    MEMORY_USED_NOARC_B="$((MEMORY_USED_B - MEMORY_WIRED_ARC_B))"
    MEMORY_UNUSED_COUNT="$((MEMORY_INACTIVE_COUNT + MEMORY_FREE_COUNT))"
    MEMORY_UNUSED_B="$((MEMORY_UNUSED_COUNT * MEMORY_PAGE_SIZE))"
    MEMORY_UNUSED_ARC_B="$((MEMORY_UNUSED_B + MEMORY_WIRED_ARC_B))"
    MEMORY_TOTAL_COUNT="$((MEMORY_ACTIVE_COUNT + MEMORY_INACTIVE_COUNT + MEMORY_LAUNDRY_COUNT + MEMORY_WIRED_COUNT + MEMORY_CACHE_COUNT + MEMORY_FREE_COUNT))"
    MEMORY_TOTAL_B="$((MEMORY_TOTAL_COUNT * MEMORY_PAGE_SIZE))"

    # calculate percentages for reporting purposes
    MEMORY_ACTIVE_PERCENTAGE="$((100 * MEMORY_ACTIVE_COUNT / MEMORY_TOTAL_COUNT))"
    MEMORY_INACTIVE_PERCENTAGE="$((100 * MEMORY_INACTIVE_COUNT / MEMORY_TOTAL_COUNT))"
    MEMORY_LAUNDRY_PERCENTAGE="$((100 * MEMORY_LAUNDRY_COUNT / MEMORY_TOTAL_COUNT))"
    MEMORY_WIRED_PERCENTAGE="$((100 * MEMORY_WIRED_COUNT / MEMORY_TOTAL_COUNT))"
    MEMORY_WIRED_ARC_PERCENTAGE="$((100 * MEMORY_WIRED_ARC_B / MEMORY_TOTAL_B))"
    MEMORY_WIRED_KERNEL_PERCENTAGE="$((100 * MEMORY_WIRED_KERNEL_B / MEMORY_TOTAL_B))"
    MEMORY_CACHE_PERCENTAGE="$((100 * MEMORY_CACHE_COUNT / MEMORY_TOTAL_COUNT))"
    MEMORY_FREE_PERCENTAGE="$((100 * MEMORY_FREE_COUNT / MEMORY_TOTAL_COUNT))"
    MEMORY_USED_PERCENTAGE="$((100 * MEMORY_USED_COUNT / MEMORY_TOTAL_COUNT))"
    MEMORY_USED_NOARC_PERCENTAGE="$((100 * MEMORY_USED_NOARC_B / MEMORY_TOTAL_B))"
    MEMORY_UNUSED_PERCENTAGE="$((100 * MEMORY_UNUSED_COUNT / MEMORY_TOTAL_COUNT))"
    MEMORY_UNUSED_ARC_PERCENTAGE="$((100 * MEMORY_UNUSED_ARC_B / MEMORY_TOTAL_B))"
    MEMORY_TOTAL_PERCENTAGE='100'

    # only a few among us like reading amounts of memory in bytes, that's why human readable
    # unit of measures will be determined for reporting purposes
    convert_bytes_to_human_readable_memory "${MEMORY_ACTIVE_B}"
    MEMORY_ACTIVE_VIEW="${MEMORY_VIEW}"
    convert_bytes_to_human_readable_memory "${MEMORY_INACTIVE_B}"
    MEMORY_INACTIVE_VIEW="${MEMORY_VIEW}"
    convert_bytes_to_human_readable_memory "${MEMORY_LAUNDRY_B}"
    MEMORY_LAUNDRY_VIEW="${MEMORY_VIEW}"
    convert_bytes_to_human_readable_memory "${MEMORY_WIRED_B}"
    MEMORY_WIRED_VIEW="${MEMORY_VIEW}"
    convert_bytes_to_human_readable_memory "${MEMORY_WIRED_ARC_B}"
    MEMORY_WIRED_ARC_VIEW="${MEMORY_VIEW}"
    convert_bytes_to_human_readable_memory "${MEMORY_WIRED_KERNEL_B}"
    MEMORY_WIRED_KERNEL_VIEW="${MEMORY_VIEW}"
    convert_bytes_to_human_readable_memory "${MEMORY_CACHE_B}"
    MEMORY_CACHE_VIEW="${MEMORY_VIEW}"
    convert_bytes_to_human_readable_memory "${MEMORY_FREE_B}"
    MEMORY_FREE_VIEW="${MEMORY_VIEW}"
    convert_bytes_to_human_readable_memory "${MEMORY_USED_B}"
    MEMORY_USED_VIEW="${MEMORY_VIEW}"
    convert_bytes_to_human_readable_memory "${MEMORY_USED_NOARC_B}"
    MEMORY_USED_NOARC_VIEW="${MEMORY_VIEW}"
    convert_bytes_to_human_readable_memory "${MEMORY_UNUSED_B}"
    MEMORY_UNUSED_VIEW="${MEMORY_VIEW}"
    convert_bytes_to_human_readable_memory "${MEMORY_UNUSED_ARC_B}"
    MEMORY_UNUSED_ARC_VIEW="${MEMORY_VIEW}"
    convert_bytes_to_human_readable_memory "${MEMORY_TOTAL_B}"
    MEMORY_TOTAL_VIEW="${MEMORY_VIEW}"
}

gather_metrics_disk() {
    # df gives a misleading view on zfs pools, so zfs is configurable in serverbot.conf
    if [ "${CONFIG_ZFS_ENABLE}" = '1' ]; then
        # this function gathers root partition metrics with help from zpool
        ROOT_PARTITION_SIZE_B="$(zpool list -H -p -o size)"
        ROOT_PARTITION_USED_B="$(zpool list -H -p -o alloc)"
        ROOT_PARTITION_FREE_B="$(zpool list -H -p -o free)"
        ROOT_PARTITION_USED_PERCENTAGE="$((100 * ROOT_PARTITION_USED_B / ROOT_PARTITION_SIZE_B))"
        ROOT_PARTITION_FREE_PERCENTAGE="$((100 * ROOT_PARTITION_FREE_B / ROOT_PARTITION_SIZE_B))"
    else
        # this function gathers root partition metrics with help from df. posix mode is used
        # for compatibility purposes
        ROOT_PARTITION_SIZE_512="$(df -P / | sed -n '2 p' | awk '{printf $4}')"
        ROOT_PARTITION_SIZE_B="$((ROOT_PARTITION_SIZE_512 * 512))"
        ROOT_PARTITION_USED_512="$(df -P / | sed -n '2 p' | awk '{printf $3}')"
        ROOT_PARTITION_USED_B="$((ROOT_PARTITION_USED_512 * 512))"
        ROOT_PARTITION_USED_PERCENTAGE="$((100 * ROOT_PARTITION_USED_512 / ROOT_PARTITION_SIZE_512))"
        ROOT_PARTITION_FREE_B="$((ROOT_PARTITION_SIZE_B - ROOT_PARTITION_USED_B))"
        ROOT_PARTITION_FREE_PERCENTAGE="$((100 * ROOT_PARTITION_FREE_B / ROOT_PARTITION_SIZE_B))"
    fi

    # only a few among us like reading amounts of memory in bytes, that's why human readable
    # unit of measures will be determined for reporting purposes
    convert_bytes_to_human_readable_disk "${ROOT_PARTITION_SIZE_B}"
    ROOT_PARTITION_SIZE_VIEW="${ROOT_PARTITION_VIEW}"
    convert_bytes_to_human_readable_disk "${ROOT_PARTITION_USED_B}"
    ROOT_PARTITION_USED_VIEW="${ROOT_PARTITION_VIEW}"
    convert_bytes_to_human_readable_disk "${ROOT_PARTITION_FREE_B}"
    ROOT_PARTITION_FREE_VIEW="${ROOT_PARTITION_VIEW}"
}

####################################################################################################
# FEATURE FUNCTIONS
####################################################################################################

feature_metrics_server_cli() {
    gather_metrics_server

    # output
    printf "%b%s%b\n" "${BOLD}" "${HOSTNAME}" "${NC}"
    printf "%b%s%b\n" "${BOLD}" "${OPERATING_SYSTEM} ${FREEBSD_VERSION} (${ARCHITECTURE})" "${NC}"
}

feature_metrics_server_telegram() {
    gather_metrics_server

    # create message for telegram
    TELEGRAM_MESSAGE="$(printf "<b>Hostname:</b>                  <code>${HOSTNAME}</code>\\n<b>os/kernel</b>:                    <code>${OPERATING_SYSTEM} ${FREEBSD_VERSION} (${ARCHITECTURE})</code>")"

    # call method_telegram
    method_telegram

    # exit when done
    exit 0
}

feature_summary_cli() {
    gather_metrics_cpu
    gather_metrics_memory
    gather_metrics_disk

    # output
    printf "%-9s %b%9s%b %1s %7s %4s%b%0s%b%0s%0s\n" "load" "${BOLD}" "${CPU_LOAD_AVERAGE_15MIN}" "${NC}" "" "" "(" "${YELLOW}" "${CPU_LOAD_PERCENTAGE_15MIN}" "${NC}" "%" ")"
    printf "%-9s %b%9s%b %b%1s%b %b%7s%b %4s%b%0s%b%0s%0s\n" "memory" "${BOLD}" "${MEMORY_USED_NOARC_VIEW}" "${NC}" "${YELLOW}" "/" "${NC}" "${BOLD}" "${MEMORY_TOTAL_VIEW}" "${NC}" "(" "${YELLOW}" "${MEMORY_USED_NOARC_PERCENTAGE}" "${NC}" "%" ")"
    printf "%-9s %b%9s%b %b%1s%b %b%7s%b %4s%b%0s%b%0s%0s\n" "disk" "${BOLD}" "${ROOT_PARTITION_USED_VIEW}" "${NC}" "${YELLOW}" "/" "${NC}" "${BOLD}" "${ROOT_PARTITION_SIZE_VIEW}" "${NC}" "(" "${YELLOW}" "${ROOT_PARTITION_USED_PERCENTAGE}" "${NC}" "%" ")"
}

feature_summary_telegram() {
    gather_metrics_server
    gather_metrics_cpu
    gather_metrics_memory
    gather_metrics_disk

    # create message for telegram
    TELEGRAM_MESSAGE="$(printf "<b>hostname:</b>                  <code>${HOSTNAME}</code>\\n<b>cpu load:</b>                     <code>${CPU_LOAD_AVERAGE_1MIN} (${CPU_LOAD_PERCENTAGE_1MIN}%%) ${CPU_LOAD_AVERAGE_5MIN} (${CPU_LOAD_PERCENTAGE_5MIN}%%) ${CPU_LOAD_AVERAGE_15MIN} (${CPU_LOAD_PERCENTAGE_15MIN}%%)</code>\\n<b>memory:</b>                     <code>${MEMORY_USED_NOARC_VIEW} (${MEMORY_USED_NOARC_PERCENTAGE}%%) / ${MEMORY_TOTAL_VIEW}</code>\\n<b>disk:</b>                              <code>${ROOT_PARTITION_USED_VIEW} (${ROOT_PARTITION_USED_PERCENTAGE}%%) / ${ROOT_PARTITION_SIZE_VIEW}</code>")"

    # call method_telegram
    method_telegram

    # exit when done
    exit 0
}

feature_overview_cli() {
    gather_metrics_server
    gather_metrics_uptime
    gather_metrics_cpu
    gather_metrics_memory
    gather_metrics_disk

    # output
    printf "hostname       %b%s%b\n" "${BOLD}" "${HOSTNAME}" "${NC}"
    printf "os/kernel      %b%s%b\n" "${BOLD}" "${OPERATING_SYSTEM} ${FREEBSD_VERSION} (${ARCHITECTURE})" "${NC}"
    printf "uptime         "
    feature_metrics_uptime_cli
    printf "\n"
    feature_metrics_cpu_cli
    printf "\n"
    feature_metrics_memory_cli
    printf "\n"
    feature_metrics_disk_cli
}

feature_overview_telegram() {
    gather_metrics_server
    gather_metrics_uptime
    gather_metrics_cpu
    gather_metrics_memory
    gather_metrics_disk

    # create message for telegram
    TELEGRAM_MESSAGE="$(printf "<b>hostname:</b>                  <code>${HOSTNAME}</code>\\n<b>os/kernel</b>:                    <code>${OPERATING_SYSTEM} ${FREEBSD_VERSION} (${ARCHITECTURE})</code>\\n<b>uptime:</b>                        <code>${UPTIME_MESSAGE}</code>\\n<b>cpu load:</b>                     <code>${CPU_LOAD_AVERAGE_1MIN} (${CPU_LOAD_PERCENTAGE_1MIN}%%) ${CPU_LOAD_AVERAGE_5MIN} (${CPU_LOAD_PERCENTAGE_5MIN}%%) ${CPU_LOAD_AVERAGE_15MIN} (${CPU_LOAD_PERCENTAGE_15MIN}%%)</code>\\n<b>memory:</b>                     <code>${MEMORY_USED_NOARC_VIEW} (${MEMORY_USED_NOARC_PERCENTAGE}%%) / ${MEMORY_TOTAL_VIEW}</code>\\n<b>disk:</b>                              <code>${ROOT_PARTITION_USED_VIEW} (${ROOT_PARTITION_USED_PERCENTAGE}%%) / ${ROOT_PARTITION_SIZE_VIEW}</code>")"

    # call method_telegram
    method_telegram

    # exit when done
    exit 0
}

feature_metrics_uptime_cli() {
    gather_metrics_uptime

    # output
    printf "%b%s%b\n" "${BOLD}" "${UPTIME_MESSAGE}" "${NC}"
}

feature_metrics_uptime_telegram() {
    gather_metrics_server
    gather_metrics_uptime

    # create message for telegram
    TELEGRAM_MESSAGE="$(printf "<b>hostname:</b>                  <code>${HOSTNAME}</code>\\n<b>uptime:</b>                        <code>${UPTIME_MESSAGE}</code>")"

    # call method_telegram
    method_telegram

    # exit when done
    exit 0
}

feature_metrics_cpu_cli() {
    gather_metrics_cpu

    # output
    printf "%-14s %-12s %-14s %-16s\n" "cpu load" "1 min" "5 min" "15 min"
    printf "%-14s %b%0s%b %0s%b%0s%b%0s%-4s %b%0s%b %0s%b%0s%b%0s%-6s %b%0s%b %0s%b%0s%b%0s%-4s\n" "" "${BOLD}" "${CPU_LOAD_AVERAGE_1MIN}" "${NC}" "(" "${YELLOW}" "${CPU_LOAD_PERCENTAGE_1MIN}" "${NC}" "%" ")" "${BOLD}" "${CPU_LOAD_AVERAGE_5MIN}" "${NC}" "(" "${YELLOW}" "${CPU_LOAD_PERCENTAGE_5MIN}" "${NC}" "%" ")" "${BOLD}" "${CPU_LOAD_AVERAGE_15MIN}" "${NC}" "(" "${YELLOW}" "${CPU_LOAD_PERCENTAGE_15MIN}" "${NC}" "%" ")"
}

feature_metrics_cpu_telegram() {
    gather_metrics_server
    gather_metrics_cpu

    # create message for telegram
    # double %% for printf to not interpret it as a argument
    TELEGRAM_MESSAGE="$(printf "<b>hostname:</b>                  <code>${HOSTNAME}</code>\\n<b>cpu load:</b>                     <code>${CPU_LOAD_AVERAGE_1MIN} (${CPU_LOAD_PERCENTAGE_1MIN}%%) ${CPU_LOAD_AVERAGE_5MIN} (${CPU_LOAD_PERCENTAGE_5MIN}%%) ${CPU_LOAD_AVERAGE_15MIN} (${CPU_LOAD_PERCENTAGE_15MIN}%%)</code>")"

    # call method_telegram
    method_telegram

    # exit when done
    exit 0
}

feature_metrics_memory_cli() {
    gather_metrics_memory

    # output
    printf "%-14s %-12s %-14s %-14s\n" "memory" "total" "used" "unused"
    printf "%-14s %b%-12s%b %b%0s%b %0s%b%0s%b%0s%-2s %b%0s%b %0s%b%0s%b%0s%-14s\n" "" "${BOLD}" "${MEMORY_TOTAL_VIEW}" "${NC}" "${BOLD}" "${MEMORY_USED_NOARC_VIEW}" "${NC}" "(" "${YELLOW}" "${MEMORY_USED_NOARC_PERCENTAGE}" "${NC}" "%" ")" "${BOLD}" "${MEMORY_UNUSED_ARC_VIEW}" "${NC}" "(" "${YELLOW}" "${MEMORY_UNUSED_ARC_PERCENTAGE}" "${NC}" "%" ")"
}

feature_metrics_memory_telegram() {
    gather_metrics_server
    gather_metrics_memory

    # create message for telegram
    TELEGRAM_MESSAGE="$(printf "<b>hostname:</b>                  <code>${HOSTNAME}</code>\\n<b>memory:</b>                     <code>${MEMORY_USED_NOARC_VIEW} (${MEMORY_USED_NOARC_PERCENTAGE}%%) / ${MEMORY_TOTAL_VIEW}</code>")"

    # call method_telegram
    method_telegram

    # exit when done
    exit 0
}

feature_metrics_memorytree_cli() {
    gather_metrics_memory

    # output
    printf "%-19s %8s %10s\n" "Total" "${MEMORY_TOTAL_VIEW}" "${MEMORY_TOTAL_PERCENTAGE}%"
    printf "%-19s %8s %10s\n" "|- Free" "${MEMORY_FREE_VIEW}" "${MEMORY_FREE_PERCENTAGE}%"
    printf "%-19s %8s %10s\n" "|- Used" "${MEMORY_USED_VIEW}" "${MEMORY_USED_PERCENTAGE}%"
    printf "%-19s %8s %10s\n" "   |- Active" "${MEMORY_ACTIVE_VIEW}" "${MEMORY_ACTIVE_PERCENTAGE}%"
    printf "%-19s %8s %10s\n" "   \`- Wired" "${MEMORY_WIRED_VIEW}" "${MEMORY_WIRED_PERCENTAGE}%"
    printf "%-19s %8s %10s\n" "      |- Kernel" "${MEMORY_WIRED_KERNEL_VIEW}" "${MEMORY_WIRED_KERNEL_PERCENTAGE}%"
    printf "%-19s %8s %10s\n" "      \`- Arc" "${MEMORY_WIRED_ARC_VIEW}" "${MEMORY_WIRED_ARC_PERCENTAGE}%"
    printf "%-19s %8s %10s\n" "|- Inactive" "${MEMORY_INACTIVE_VIEW}" "${MEMORY_INACTIVE_PERCENTAGE}%"
    printf "%-19s %8s %10s\n" "|- Laundry" "${MEMORY_LAUNDRY_VIEW}" "${MEMORY_LAUNDRY_PERCENTAGE}%"
    printf "%-19s %8s %10s\n" "\`- Cache" "${MEMORY_CACHE_VIEW}" "${MEMORY_CACHE_PERCENTAGE}%"
}

feature_metrics_memorytree_telegram() {
    error_method_not_supported

    # exit when done
    exit 0
}

feature_metrics_disk_cli() {
    gather_metrics_disk

    # output
    printf "%-14s %-12s %-14s %-14s\n" "disk usage" "total" "used" "free"
    printf "%-14s %b%-12s%b %b%0s%b %0s%b%0s%b%0s%-5s %b%0s%b %0s%b%0s%b%0s%-14s\n" "" "${BOLD}" "${ROOT_PARTITION_SIZE_VIEW}" "${NC}" "${BOLD}" "${ROOT_PARTITION_USED_VIEW}" "${NC}" "(" "${YELLOW}" "${ROOT_PARTITION_USED_PERCENTAGE}" "${NC}" "%" ")" "${BOLD}" "${ROOT_PARTITION_FREE_VIEW}" "${NC}" "(" "${YELLOW}" "${ROOT_PARTITION_FREE_PERCENTAGE}" "${NC}" "%" ")"
}

feature_metrics_disk_telegram() {
    gather_metrics_server
    gather_metrics_disk

    # create message for telegram
    TELEGRAM_MESSAGE="$(printf "<b>hostname:</b>                  <code>${HOSTNAME}</code>\\n<b>disk:</b>                              <code>${ROOT_PARTITION_USED_VIEW} (${ROOT_PARTITION_USED_PERCENTAGE}%%) / ${ROOT_PARTITION_SIZE_VIEW}</code>")"

    # call method_telegram
    method_telegram

    # exit when done
    exit 0
}

feature_metrics_network_cli() {
    echo 'WIP'
    # ifconfig <interface> | grep 'inet' | awk -F ' ' '{ print $2 }'
}

feature_metrics_network_telegram() {
    echo 'WIP'
    # ifconfig <interface> | grep 'inet' | awk -F ' ' '{ print $2 }'

    # exit when done
    exit 0
}

feature_metrics_alert_cli() {
    gather_metrics_cpu
    gather_metrics_memory
    gather_metrics_disk

    # output
    if [ "${CPU_LOAD_PERCENTAGE_15MIN}" -gt "${CONFIG_THRESHOLD_LOAD}" ]; then
        printf "%b[!]%b %bcurrent server load of%b %b%s%b%b%%  exceeds the threshold of%b %b%s%b%b%%%b\n" "${LRED}" "${NC}" "${BOLD}" "${NC}" "${LRED}" "${CPU_LOAD_PERCENTAGE_15MIN}" "${NC}" "${BOLD}" "${NC}" "${YELLOW}" "${CONFIG_THRESHOLD_LOAD}" "${NC}" "${BOLD}" "${NC}"
    else
        printf "%b[i]%b %bcurrent server load of%b %b%s%b%b%% does not exceed the threshold of%b %b%s%b%b%%%b\n" "${YELLOW}" "${NC}" "${BOLD}" "${NC}" "${YELLOW}" "${CPU_LOAD_PERCENTAGE_15MIN}" "${NC}" "${BOLD}" "${NC}" "${YELLOW}" "${CONFIG_THRESHOLD_LOAD}" "${NC}" "${BOLD}" "${NC}"
    fi
    if [ "${MEMORY_USED_NOARC_PERCENTAGE}" -gt "${CONFIG_THRESHOLD_MEMORY}" ]; then
        printf "%b[!]%b %bcurrent memory usage of%b %b%s%b%b%% exceeds the threshold of%b %b%s%b%b%%%b\n" "${LRED}" "${NC}" "${BOLD}" "${NC}" "${LRED}" "${MEMORY_USED_NOARC_PERCENTAGE}" "${NC}" "${BOLD}" "${NC}" "${YELLOW}" "${CONFIG_THRESHOLD_MEMORY}" "${NC}" "${BOLD}" "${NC}"
    else
        printf "%b[i]%b %bcurrent memory usage of%b %b%s%b%b%% does not exceed the threshold of%b %b%s%b%b%%%b\n" "${YELLOW}" "${NC}" "${BOLD}" "${NC}" "${YELLOW}" "${MEMORY_USED_NOARC_PERCENTAGE}" "${NC}" "${BOLD}" "${NC}" "${YELLOW}" "${CONFIG_THRESHOLD_MEMORY}" "${NC}" "${BOLD}" "${NC}"
    fi
    if [ "${ROOT_PARTITION_USED_PERCENTAGE}" -gt "${CONFIG_THRESHOLD_DISK}" ]; then
        printf "%b[!]%b %bcurrent disk usage of%b %b%s%b%b%% exceeds the threshold of%b %b%s%b%b%%%b\n" "${LRED}" "${NC}" "${BOLD}" "${NC}" "${LRED}" "${ROOT_PARTITION_USED_PERCENTAGE}" "${NC}" "${BOLD}" "${NC}" "${YELLOW}" "${CONFIG_THRESHOLD_DISK}" "${NC}" "${BOLD}" "${NC}"
    else
        printf "%b[i]%b %bcurrent disk usage of%b %b%s%b%b%% does not exceed the threshold of%b %b%s%b%b%%%b\n" "${YELLOW}" "${NC}" "${BOLD}" "${NC}" "${YELLOW}" "${ROOT_PARTITION_USED_PERCENTAGE}" "${NC}" "${BOLD}" "${NC}" "${YELLOW}" "${CONFIG_THRESHOLD_DISK}" "${NC}" "${BOLD}" "${NC}"
    fi
}

feature_metrics_alert_telegram() {
    gather_metrics_server
    gather_metrics_cpu
    gather_metrics_memory
    gather_metrics_disk

    # output
    if [ "${CPU_LOAD_PERCENTAGE_15MIN}" -gt "${CONFIG_THRESHOLD_LOAD}" ]; then
        # create message for telegram
        TELEGRAM_MESSAGE="$(echo -e "%e2%9a%a0 <b>[ALERT]</b> <code>${HOSTNAME}</code>\\nCurrent server load (${CPU_LOAD_PERCENTAGE_15MIN}%) exceeds the threshold (${CONFIG_THRESHOLD_LOAD}%).")"

        # call method_telegram
        method_telegram
    fi
    if [ "${MEMORY_USED_NOARC_PERCENTAGE}" -gt "${CONFIG_THRESHOLD_MEMORY}" ]; then
        # create message for telegram
        TELEGRAM_MESSAGE="$(echo -e "%e2%9a%a0 <b>[ALERT]</b> <code>${HOSTNAME}</code>\\nCurrent memory usage (${MEMORY_USED_NOARC_PERCENTAGE}%) exceeds the threshold (${CONFIG_THRESHOLD_MEMORY}%).")"

        # call method_telegram
        method_telegram
    fi
    if [ "${ROOT_PARTITION_USED_PERCENTAGE}" -gt "${CONFIG_THRESHOLD_DISK}" ]; then
        # create message for telegram
        TELEGRAM_MESSAGE="$(echo -e "%e2%9a%a0 <b>[ALERT]</b> <code>${HOSTNAME}</code>\\nCurrent disk usage (${ROOT_PARTITION_USED_PERCENTAGE}%) exceeds the threshold (${CONFIG_THRESHOLD_DISK}%).")"

        # call method_telegram
        method_telegram
    fi

    # exit when done
    exit 0
}

####################################################################################################
# METHOD FUNCTIONS
####################################################################################################

method_telegram() {
    requirement_curl

    if [ "${METHOD_TELEGRAM}" = '1' ]; then
        TELEGRAM_URL="https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage"

        # create payload for Telegram
        TELEGRAM_PAYLOAD="chat_id=${TELEGRAM_CHAT}&text=${TELEGRAM_MESSAGE}&parse_mode=HTML&disable_web_page_preview=true"

        # sent payload to Telegram API and exit
        "${CURL}" --silent --max-time 10 --retry 5 --retry-delay 2 --retry-max-time 10 -d "${TELEGRAM_PAYLOAD}" "${TELEGRAM_URL}" > /dev/null 2>&1 &
    else
        error_telegram_not_configured
    fi
}

####################################################################################################
# MAIN FUNCTIONS
####################################################################################################

serverbot_main() {
    requirement_os
    serverbot_argument_validate

    # when both a feature and method cli are given
    if [ "${ARGUMENT_SERVER}" = '1' ] && [ "${ARGUMENT_CLI}" = '1' ]; then
        feature_metrics_server_cli
    elif [ "${ARGUMENT_SUMMARY}" = '1' ] && [ "${ARGUMENT_CLI}" = '1' ]; then
        feature_summary_cli
    elif [ "${ARGUMENT_OVERVIEW}" = '1' ] && [ "${ARGUMENT_CLI}" = '1' ]; then
        feature_overview_cli
    elif [ "${ARGUMENT_UPTIME}" = '1' ] && [ "${ARGUMENT_CLI}" = '1' ]; then
        feature_metrics_uptime_cli
    elif [ "${ARGUMENT_CPU}" = '1' ] && [ "${ARGUMENT_CLI}" = '1' ]; then
        feature_metrics_cpu_cli
    elif [ "${ARGUMENT_MEMORY}" = '1' ] && [ "${ARGUMENT_CLI}" = '1' ]; then
        feature_metrics_memory_cli
    elif [ "${ARGUMENT_MEMORYTREE}" = '1' ] && [ "${ARGUMENT_CLI}" = '1' ]; then
        feature_metrics_memorytree_cli
    elif [ "${ARGUMENT_DISK}" = '1' ] && [ "${ARGUMENT_CLI}" = '1' ]; then
        feature_metrics_disk_cli
    elif [ "${ARGUMENT_NETWORK}" = '1' ] && [ "${ARGUMENT_CLI}" = '1' ]; then
        feature_metrics_network_cli
    elif [ "${ARGUMENT_ALERT}" = '1' ] && [ "${ARGUMENT_CLI}" = '1' ]; then
        feature_metrics_alert_cli
    elif [ "${ARGUMENT_SERVER}" = '1' ] && [ "${ARGUMENT_TELEGRAM}" = '1' ]; then
        feature_metrics_server_telegram
    elif [ "${ARGUMENT_SUMMARY}" = '1' ] && [ "${ARGUMENT_TELEGRAM}" = '1' ]; then
        feature_summary_telegram
    elif [ "${ARGUMENT_OVERVIEW}" = '1' ] && [ "${ARGUMENT_TELEGRAM}" = '1' ]; then
        feature_overview_telegram
    elif [ "${ARGUMENT_UPTIME}" = '1' ] && [ "${ARGUMENT_TELEGRAM}" = '1' ]; then
        feature_metrics_uptime_telegram
    elif [ "${ARGUMENT_CPU}" = '1' ] && [ "${ARGUMENT_TELEGRAM}" = '1' ]; then
        feature_metrics_cpu_telegram
    elif [ "${ARGUMENT_MEMORY}" = '1' ] && [ "${ARGUMENT_TELEGRAM}" = '1' ]; then
        feature_metrics_memory_telegram
    elif [ "${ARGUMENT_MEMORYTREE}" = '1' ] && [ "${ARGUMENT_TELEGRAM}" = '1' ]; then
        feature_metrics_memorytree_telegram
    elif [ "${ARGUMENT_DISK}" = '1' ] && [ "${ARGUMENT_TELEGRAM}" = '1' ]; then
        feature_metrics_disk_telegram
    elif [ "${ARGUMENT_NETWORK}" = '1' ] && [ "${ARGUMENT_TELEGRAM}" = '1' ]; then
        feature_metrics_network_telegram
    elif [ "${ARGUMENT_ALERT}" = '1' ] && [ "${ARGUMENT_TELEGRAM}" = '1' ]; then
        feature_metrics_alert_telegram
    # method cli is the default method, so even when no method is given method cli is used
    elif [ "${ARGUMENT_SERVER}" = '1' ]; then
        feature_metrics_server_cli
    elif [ "${ARGUMENT_SUMMARY}" = '1' ]; then
        feature_summary_cli
    elif [ "${ARGUMENT_OVERVIEW}" = '1' ]; then
        feature_overview_cli
    elif [ "${ARGUMENT_UPTIME}" = '1' ]; then
        feature_metrics_uptime_cli
    elif [ "${ARGUMENT_CPU}" = '1' ]; then
        feature_metrics_cpu_cli
    elif [ "${ARGUMENT_MEMORY}" = '1' ]; then
        feature_metrics_memory_cli
    elif [ "${ARGUMENT_MEMORYTREE}" = '1' ]; then
        feature_metrics_memorytree_cli
    elif [ "${ARGUMENT_DISK}" = '1' ]; then
        feature_metrics_disk_cli
    elif [ "${ARGUMENT_NETWORK}" = '1' ]; then
        feature_metrics_network_cli
    elif [ "${ARGUMENT_ALERT}" = '1' ]; then
        feature_metrics_alert_cli
    elif [ "${ARGUMENT_CRON}" = '1' ]; then
        option_cron
    elif [ "${ARGUMENT_VERSION}" = '1' ]; then
        option_version
    elif [ "${ARGUMENT_HELP}" = '1' ]; then
        option_help
    # the overview is shown when no arguments were given
    else
        feature_overview_cli
    fi
}

####################################################################################################
# CALL MAIN FUNCTIONS
####################################################################################################

serverbot_main
