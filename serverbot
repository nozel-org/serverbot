#!/bin/sh

#############################################################################
# Version 1.11.0-RELEASE (30-03-2024)
#############################################################################

#############################################################################
# SPDX-License-Identifier: Apache-2.0
#
# Copyright 2016 Sebas Veeke. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#############################################################################

#############################################################################
# Contact:
# > E-mail      mail@nozel.org
# > Website     https://nozel.org
# > Codeberg    https://codeberg.org/nozel/serverbot
#############################################################################

#############################################################################
# PROGRAM VARIABLES
#############################################################################

# version and date
SERVERBOT_VERSION='1.11.0'
SERVERBOT_VERSION_DATE='30-03-2024'

# file locations
SERVERBOT_CONFIGURATION='/usr/local/etc/serverbot.conf'
SERVERBOT_CRONFILE='/etc/cron.d/serverbot'

# commands
CURL="$(command -v curl)"

# colors
NC='\033[0;0m'
BOLD='\033[1m'
YELLOW='\033[1;33m'
LRED='\033[1;31m'
LGREEN='\033[1;32m'
#LMAGENTA='\033[1;35m'
#LCYAN='\033[1;36m'
#WHITE='\033[1;37m'

#############################################################################
# CONFIGURATION FILE HANDLING
#############################################################################

# check whether serverbot.conf is available and source it
if [ -f "${SERVERBOT_CONFIGURATION}" ]; then
    # populate all usable variables to have defaults and check validity later on
    SMT_ENABLE='0'
    LOAD_INTERVAL='0'
    ZFS_ENABLE='0'
    THRESHOLD_LOAD='0'
    THRESHOLD_MEMORY='0'
    THRESHOLD_DISK='0'
    THRESHOLD_CPUTEMP='0'
    SUMMARY_LOGGER='0'
    SUMMARY_TELEGRAM='0'
    SUMMARY_CRON='0'
    OVERVIEW_LOGGER='0'
    OVERVIEW_TELEGRAM='0'
    OVERVIEW_CRON='0'
    ALERT_LOGGER='0'
    ALERT_TELEGRAM='0'
    ALERT_CRON='0'
    BASE_UPDATES_LOGGER='0'
    BASE_UPDATES_TELEGRAM='0'
    BASE_UPDATES_CRON='0'
    PKG_UPDATES_LOGGER='0'
    PKG_UPDATES_TELEGRAM='0'
    PKG_UPDATES_CRON='0'
    PKG_AUDIT_LOGGER='0'
    PKG_AUDIT_TELEGRAM='0'
    PKG_AUDIT_CRON='0'
    PKG_CHECKSUM_LOGGER='0'
    PKG_CHECKSUM_TELEGRAM='0'
    PKG_CHECKSUM_CRON='0'
    TELEGRAM_TOKEN='0'
    TELEGRAM_CHAT='0'

    # and source serverbot.conf
    . "${SERVERBOT_CONFIGURATION}"

    # check whether serverbot.conf configuration parameters are used
    # general settings
    if [ "${SMT_ENABLE}" = 'yes' ] || [ "${SMT_ENABLE}" = 'YES' ]; then
        CONFIG_SMT_ENABLE='1'
    else
        CONFIG_SMT_ENABLE='0'
    fi
    if [ "${ZFS_ENABLE}" = 'yes' ] || [ "${ZFS_ENABLE}" = 'YES' ]; then
        CONFIG_ZFS_ENABLE='1'
    else
        CONFIG_ZFS_ENABLE='0'
    fi
    # alert configuration
    if [ "${LOAD_INTERVAL}" = '1' ]; then
        CONFIG_LOAD_INTERVAL='1'
    elif [ "${LOAD_INTERVAL}" = '5' ]; then
        CONFIG_LOAD_INTERVAL='5'
    elif [ "${LOAD_INTERVAL}" = '15' ]; then
        CONFIG_LOAD_INTERVAL='15'
    else
        CONFIG_LOAD_INTERVAL='15'
    fi
    if [ "${THRESHOLD_LOAD}" -lt '0' ]; then
        CONFIG_THRESHOLD_LOAD='95'
    elif [ "${THRESHOLD_LOAD}" -gt '0' ]; then
        CONFIG_THRESHOLD_LOAD="${THRESHOLD_LOAD}"
    else
        CONFIG_THRESHOLD_LOAD='95'
    fi
    if [ "${THRESHOLD_MEMORY}" -lt '0' ] || [ "${THRESHOLD_MEMORY}" -gt '100' ]; then
        CONFIG_THRESHOLD_MEMORY='90'
    elif [ "${THRESHOLD_MEMORY}" -gt '0' ] || [ "${THRESHOLD_MEMORY}" -le '100' ]; then
        CONFIG_THRESHOLD_MEMORY="${THRESHOLD_MEMORY}"
    else
        CONFIG_THRESHOLD_MEMORY='90'
    fi
    if [ "${THRESHOLD_DISK}" -lt '0' ] || [ "${THRESHOLD_DISK}" -gt '100' ]; then
        CONFIG_THRESHOLD_DISK='80'
    elif [ "${THRESHOLD_DISK}" -gt '0' ] && [ "${THRESHOLD_DISK}" -le '100' ]; then
        CONFIG_THRESHOLD_DISK="${THRESHOLD_DISK}"
    else
        CONFIG_THRESHOLD_DISK='80'
    fi
    if [ "${THRESHOLD_CPUTEMP}" -lt '0' ]; then
        CONFIG_THRESHOLD_CPUTEMP='95'
    elif [ "${THRESHOLD_CPUTEMP}" -gt '0' ]; then
        CONFIG_THRESHOLD_CPUTEMP="${THRESHOLD_CPUTEMP}"
    else
        CONFIG_THRESHOLD_CPUTEMP='95'
    fi
    # automated summary task
    if [ "${SUMMARY_LOGGER}" = 'yes' ] || [ "${SUMMARY_LOGGER}" = 'YES' ]; then
        CONFIG_SUMMARY_LOGGER='1'
    else
        CONFIG_SUMMARY_LOGGER='0'
    fi
    if [ "${SUMMARY_TELEGRAM}" = 'yes' ] || [ "${SUMMARY_TELEGRAM}" = 'YES' ]; then
        CONFIG_SUMMARY_TELEGRAM='1'
    else
        CONFIG_SUMMARY_TELEGRAM='0'
    fi
    if [ "${SUMMARY_CRON}" = '0' ]; then
        CONFIG_SUMMARY_CRON='0'
    else
        CONFIG_SUMMARY_CRON='1'
    fi
    # automated overview task
    if [ "${OVERVIEW_LOGGER}" = 'yes' ] || [ "${OVERVIEW_LOGGER}" = 'YES' ]; then
        CONFIG_OVERVIEW_LOGGER='1'
    else
        CONFIG_OVERVIEW_LOGGER='0'
    fi
    if [ "${OVERVIEW_TELEGRAM}" = 'yes' ] || [ "${OVERVIEW_TELEGRAM}" = 'YES' ]; then
        CONFIG_OVERVIEW_TELEGRAM='1'
    else
        CONFIG_OVERVIEW_TELEGRAM='0'
    fi
    if [ "${OVERVIEW_CRON}" = '0' ]; then
        CONFIG_OVERVIEW_CRON='0'
    else
        CONFIG_OVERVIEW_CRON='1'
    fi
    # automated alert task
    if [ "${ALERT_LOGGER}" = 'yes' ] || [ "${ALERT_LOGGER}" = 'YES' ]; then
        CONFIG_ALERT_LOGGER='1'
    else
        CONFIG_ALERT_LOGGER='0'
    fi
    if [ "${ALERT_TELEGRAM}" = 'yes' ] || [ "${ALERT_TELEGRAM}" = 'YES' ]; then
        CONFIG_ALERT_TELEGRAM='1'
    else
        CONFIG_ALERT_TELEGRAM='0'
    fi
    if [ "${ALERT_CRON}" = '0' ]; then
        CONFIG_ALERT_CRON='0'
    else
        CONFIG_ALERT_CRON='1'
    fi
    # automated baseupdates task
    if [ "${BASE_UPDATES_LOGGER}" = 'yes' ] || [ "${BASE_UPDATES_LOGGER}" = 'YES' ]; then
        CONFIG_BASEUPDATES_LOGGER='1'
    else
        CONFIG_BASEUPDATES_LOGGER='0'
    fi
    if [ "${BASE_UPDATES_TELEGRAM}" = 'yes' ] || [ "${BASE_UPDATES_TELEGRAM}" = 'YES' ]; then
        CONFIG_BASEUPDATES_TELEGRAM='1'
    else
        CONFIG_BASEUPDATES_TELEGRAM='0'
    fi
    if [ "${BASE_UPDATES_CRON}" = '0' ]; then
        CONFIG_BASEUPDATES_CRON='0'
    else
        CONFIG_BASEUPDATES_CRON='1'
    fi
    # automated pkgupdates task
    if [ "${PKG_UPDATES_LOGGER}" = 'yes' ] || [ "${PKG_UPDATES_LOGGER}" = 'YES' ]; then
        CONFIG_PKGUPDATES_LOGGER='1'
    else
        CONFIG_PKGUPDATES_LOGGER='0'
    fi
    if [ "${PKG_UPDATES_TELEGRAM}" = 'yes' ] || [ "${PKG_UPDATES_TELEGRAM}" = 'YES' ]; then
        CONFIG_PKGUPDATES_TELEGRAM='1'
    else
        CONFIG_PKGUPDATES_TELEGRAM='0'
    fi
    if [ "${PKG_UPDATES_CRON}" = '0' ]; then
        CONFIG_PKGUPDATES_CRON='0'
    else
        CONFIG_PKGUPDATES_CRON='1'
    fi
    # automated pkgaudit task
    if [ "${PKG_AUDIT_LOGGER}" = 'yes' ] || [ "${PKG_AUDIT_LOGGER}" = 'YES' ]; then
        CONFIG_PKGAUDIT_LOGGER='1'
    else
        CONFIG_PKGAUDIT_LOGGER='0'
    fi
    if [ "${PKG_AUDIT_TELEGRAM}" = 'yes' ] || [ "${PKG_AUDIT_TELEGRAM}" = 'YES' ]; then
        CONFIG_PKGAUDIT_TELEGRAM='1'
    else
        CONFIG_PKGAUDIT_TELEGRAM='0'
    fi
    if [ "${PKG_AUDIT_CRON}" = '0' ]; then
        CONFIG_PKGAUDIT_CRON='0'
    else
        CONFIG_PKGAUDIT_CRON='1'
    fi
    # automated pkgchecksum task
    if [ "${PKG_CHECKSUM_LOGGER}" = 'yes' ] || [ "${PKG_CHECKSUM_LOGGER}" = 'YES' ]; then
        CONFIG_PKGCHECKSUM_LOGGER='1'
    else
        CONFIG_PKGCHECKSUM_LOGGER='0'
    fi
    if [ "${PKG_CHECKSUM_TELEGRAM}" = 'yes' ] || [ "${PKG_CHECKSUM_TELEGRAM}" = 'YES' ]; then
        CONFIG_PKGCHECKSUM_TELEGRAM='1'
    else
        CONFIG_PKGCHECKSUM_TELEGRAM='0'
    fi
    if [ "${PKG_CHECKSUM_CRON}" = '0' ]; then
        CONFIG_PKGCHECKSUM_CRON='0'
    else
        CONFIG_PKGCHECKSUM_CRON='1'
    fi
    # telegram configuration
    if [ "${TELEGRAM_TOKEN}" = '0' ] || [ "${TELEGRAM_CHAT}" = '0' ]; then
        METHOD_TELEGRAM='0'
    else
        METHOD_TELEGRAM='1'
    fi
# use sane defaults when backupbot.conf is not available
else
    CONFIG_SMT_ENABLE='0'
    CONFIG_LOAD_INTERVAL='15'
    CONFIG_ZFS_ENABLE='0'
    CONFIG_THRESHOLD_LOAD='95'
    CONFIG_THRESHOLD_MEMORY='90'
    CONFIG_THRESHOLD_DISK='80'
    CONFIG_THRESHOLD_CPUTEMP='95'
    CONFIG_SUMMARY_LOGGER='0'
    CONFIG_SUMMARY_TELEGRAM='0'
    CONFIG_SUMMARY_CRON='0'
    CONFIG_OVERVIEW_LOGGER='0'
    CONFIG_OVERVIEW_TELEGRAM='0'
    CONFIG_OVERVIEW_CRON='0'
    CONFIG_ALERT_LOGGER='0'
    CONFIG_ALERT_TELEGRAM='0'
    CONFIG_ALERT_CRON='0'
    CONFIG_BASEUPDATES_LOGGER='0'
    CONFIG_BASEUPDATES_TELEGRAM='0'
    CONFIG_BASEUPDATES_CRON='0'
    CONFIG_PKGUPDATES_LOGGER='0'
    CONFIG_PKGUPDATES_TELEGRAM='0'
    CONFIG_PKGUPDATES_CRON='0'
    CONFIG_PKGAUDIT_LOGGER='0'
    CONFIG_PKGAUDIT_TELEGRAM='0'
    CONFIG_PKGAUDIT_CRON='0'
    CONFIG_PKGCHECKSUM_LOGGER='0'
    CONFIG_PKGCHECKSUM_TELEGRAM='0'
    CONFIG_PKGCHECKSUM_CRON='0'
fi

# combining automated feature tasks for more fine-grained control
AUTOMATED_TASKS_COMBINED="$((CONFIG_SUMMARY_LOGGER + CONFIG_SUMMARY_TELEGRAM + CONFIG_OVERVIEW_LOGGER + CONFIG_OVERVIEW_TELEGRAM + CONFIG_ALERT_LOGGER + CONFIG_ALERT_TELEGRAM + CONFIG_BASEUPDATES_LOGGER + CONFIG_BASEUPDATES_TELEGRAM + CONFIG_PKGUPDATES_LOGGER + CONFIG_PKGUPDATES_TELEGRAM + CONFIG_PKGAUDIT_LOGGER + CONFIG_PKGAUDIT_TELEGRAM + CONFIG_PKGCHECKSUM_LOGGER + CONFIG_PKGCHECKSUM_TELEGRAM))"
AUTOMATED_SUMMARY_TASKS_COMBINED="$((CONFIG_SUMMARY_LOGGER + CONFIG_SUMMARY_TELEGRAM))"
AUTOMATED_OVERVIEW_TASKS_COMBINED="$((CONFIG_OVERVIEW_LOGGER + CONFIG_OVERVIEW_TELEGRAM))"
AUTOMATED_ALERT_TASKS_COMBINED="$((CONFIG_ALERT_LOGGER + CONFIG_ALERT_TELEGRAM))"
AUTOMATED_BASEUPDATES_TASKS_COMBINED="$((CONFIG_BASEUPDATES_LOGGER + CONFIG_BASEUPDATES_TELEGRAM))"
AUTOMATED_PKGUPDATES_TASKS_COMBINED="$((CONFIG_PKGUPDATES_LOGGER + CONFIG_PKGUPDATES_TELEGRAM))"
AUTOMATED_PKGAUDIT_TASKS_COMBINED="$((CONFIG_PKGAUDIT_LOGGER + CONFIG_PKGAUDIT_TELEGRAM))"
AUTOMATED_PKGCHECKSUM_TASKS_COMBINED="$((CONFIG_PKGCHECKSUM_LOGGER + CONFIG_PKGCHECKSUM_TELEGRAM))"

####################################################################################################
# ARGUMENT HANDLING
####################################################################################################

# populate validation variables with zeros for validation
ARGUMENT_VERSION='0'
ARGUMENT_HELP='0'
ARGUMENT_CRON='0'
ARGUMENT_BASIC='0'
ARGUMENT_SUMMARY='0'
ARGUMENT_OVERVIEW='0'
ARGUMENT_UPTIME='0'
ARGUMENT_CPU='0'
ARGUMENT_MEMORY='0'
ARGUMENT_MEMORYTREE='0'
ARGUMENT_DISK='0'
ARGUMENT_NETWORK='0'
ARGUMENT_ALERT='0'
ARGUMENT_BASEUPDATES='0'
ARGUMENT_PKGUPDATES='0'
ARGUMENT_PKGAUDIT='0'
ARGUMENT_PKGCHECKSUM='0'
ARGUMENT_CLI='0'
ARGUMENT_LOGGER='0'
ARGUMENT_TELEGRAM='0'

# read arguments
while test -n "$1"; do
    case "$1" in
        # options
        --version|-version|version|--v|-v)
            ARGUMENT_VERSION='1'
            shift
            ;;

        --help|-help|help|--h|-h)
            ARGUMENT_HELP='1'
            shift
            ;;
        
        --cron|-cron|cron)
            ARGUMENT_CRON='1'
            shift
            ;;

        # features
        --basic|basic|-b)
            ARGUMENT_BASIC='1'
            shift
            ;;

        --summary|summary|-s)
            ARGUMENT_SUMMARY='1'
            shift
            ;;

        --overview|overview|-o)
            ARGUMENT_OVERVIEW='1'
            shift
            ;;

        --uptime|uptime)
            ARGUMENT_UPTIME='1'
            shift
            ;;

        --cpu|cpu|processor)
            ARGUMENT_CPU='1'
            shift
            ;;

        --memory|memory|ram)
            ARGUMENT_MEMORY='1'
            shift
            ;;

        --memorytree|memorytree|-M)
            ARGUMENT_MEMORYTREE='1'
            shift
            ;;

        --disk|disk|hdd|ssd)
            ARGUMENT_DISK='1'
            shift
            ;;

        --network|network)
            ARGUMENT_NETWORK='1'
            shift
            ;;

        --alert|alert|-a)
            ARGUMENT_ALERT='1'
            shift
            ;;

        --baseupdates|baseupdates)
            ARGUMENT_BASEUPDATES='1'
            shift
            ;;

        --pkgupdates|pkgupdates)
            ARGUMENT_PKGUPDATES='1'
            shift
            ;;

        --pkgaudit|pkgaudit)
            ARGUMENT_PKGAUDIT='1'
            shift
            ;;

        --pkgchecksum|pkgchecksum)
            ARGUMENT_PKGCHECKSUM='1'
            shift
            ;;

        # methods
        --cli|cli|-c)
            ARGUMENT_CLI='1'
            shift
            ;;

        --logger|logger|-l)
            ARGUMENT_LOGGER='1'
            shift
            ;;

        --telegram|telegram|-t)
            ARGUMENT_TELEGRAM='1'
            shift
            ;;

        # other
        *)
            ARGUMENT_NONE='1'
            shift
            ;;
    esac
done

####################################################################################################
# ERROR FUNCTIONS
####################################################################################################

program_error() {
    printf "serverbot: error: %s %s %s\n" "${1}" "${2}" "${3}"
    exit 1
}

####################################################################################################
# REQUIREMENT AND VALIDATION FUNCTIONS
####################################################################################################

requirement_root() {
    # show error if updatebot isn't run with root privileges
    if [ "$(id -u)" -ne '0' ]; then
        program_error 'this feature must be run with root privileges'
    fi
}

requirement_os() {
    # show error if freebsd-version cannot be found
    if [ ! "$(command -v freebsd-version)" ]; then
        program_error 'operating system is not supported'
    fi
}

requirement_curl() {
    # show error if curl cannot be found (which probably means the user has not installed curl)
    if [ ! "$(command -v curl)" ]; then
        program_error 'curl is not installed'
    fi
}

serverbot_argument_validate() {
    # # populate validation variables with zeros for validation
    ARGUMENT_OPTIONS_COMBINED='0'
    ARGUMENT_FEATURES_COMBINED='0'
    ARGUMENT_METHODS_COMBINED='0'

    # combine argument categories
    ARGUMENT_OPTIONS_COMBINED="$((ARGUMENT_VERSION + ARGUMENT_HELP + ARGUMENT_CRON))"
    ARGUMENT_FEATURES_COMBINED="$((ARGUMENT_BASIC + ARGUMENT_SUMMARY + ARGUMENT_OVERVIEW + ARGUMENT_UPTIME + ARGUMENT_CPU + ARGUMENT_MEMORY + ARGUMENT_MEMORYTREE + ARGUMENT_DISK + ARGUMENT_NETWORK + ARGUMENT_ALERT + ARGUMENT_BASEUPDATES + ARGUMENT_PKGUPDATES + ARGUMENT_PKGAUDIT + ARGUMENT_PKGCHECKSUM))"
    ARGUMENT_METHODS_COMBINED="$((ARGUMENT_CLI + ARGUMENT_LOGGER + ARGUMENT_TELEGRAM))"

    # show error if a unsupported argument is used    
    if [ "${ARGUMENT_NONE}" = '1' ]; then
        program_error 'invalid argument used'
    # validate amount of selected options and return error if more than 1 option is used
    elif [ "${ARGUMENT_OPTIONS_COMBINED}" -gt '1' ]; then
        program_error 'only one serverbot option can be used at a time'
    # validate amount of selected features and return error if more than 1 feature is used
    elif [ "${ARGUMENT_FEATURES_COMBINED}" -gt '1' ]; then
        program_error 'only one serverbot feature can be used at a time'
    # validate whether a option and feature are used at the same time and return error if this is the case
    elif [ "${ARGUMENT_OPTIONS_COMBINED}" -ge '1' ] && [ "${ARGUMENT_FEATURES_COMBINED}" -ge '1' ]; then
        program_error 'options and features cannot be used at the same time'
    # validate whether a option and method are used at the same time and return error if this is the case
    elif [ "${ARGUMENT_OPTIONS_COMBINED}" -ge '1' ] && [ "${ARGUMENT_METHODS_COMBINED}" -ge '1' ]; then
        program_error 'options and methods cannot be used at the same time'
    # validate whether a method is used without a feature and return error if this is the case
    elif [ "${ARGUMENT_METHODS_COMBINED}" -ge '1' ] && [ "${ARGUMENT_FEATURES_COMBINED}" = '0' ]; then
        program_error 'a feature must be used when a method is used'
    fi
}

####################################################################################################
# GENERAL FUNCTIONS
####################################################################################################

option_version() {
    printf "Serverbot %s (%s)\n" "${SERVERBOT_VERSION}" "${SERVERBOT_VERSION_DATE}"
    printf "Copyright (C) 2016 S. Veeke. All rights reserved.\n"
    printf "SPDX-License-Identifier: Apache-2.0.\n"
    exit 0
}

option_help() {
    printf "Usage:\n"
    printf "  serverbot [feature]                    # No explicit method defaults to method cli\n"
    printf "  serverbot [feature] [method]           # Only one feature can be used at a time\n"
    printf "  serverbot [feature] [method] [method]  # Multiple methods can be used at once\n"
    printf "  serverbot [option]\n\n"
    printf "Features:\n"
    printf "  -b, --basic                Basic server information\n"
    printf "  -s, --summary              Server metrics overview\n"
    printf "  -o, --overview             Extended server overview\n"
    printf "      --uptime               Server uptime metrics\n"
    printf "      --cpu                  CPU load metrics\n"
    printf "      --memory               Basic memory usage metrics\n"
    printf "  -M, --memorytree           Extended memory usage metrics\n"
    printf "      --disk                 Disk usage metrics\n"
    #printf "      --network              Interfaces and IP addresses\n"
    printf "      --alert                Reports whether metric and temperature thresholds are reached\n"
    printf "      --baseupdates          Reports about available base system updates\n"
    printf "      --pkgupdates           Reports about available package updates\n"
    printf "      --pkgaudit             Reports about known package vulnerabilities\n"
    printf "      --pkgchecksum          Reports about mismatching package checksums\n\n"
    printf "Methods:\n"
    printf "  -c, --cli (default)        Output [feature] to command line\n"
    printf "  -l, --logger               Output [feature] to logger\n"
    printf "  -t, --telegram             Output [feature] to Telegram\n\n"
    #printf "  -m, --mail                 Output [feature] to mail\n\n"
    printf "Options:\n"
    printf "  --cron                     Effectuate cron changes from serverbot config\n"
    printf "  --help                     Display this help and exit\n"
    printf "  --version                  Display version information and exit\n"
    exit 0
}

option_cron() {
    requirement_root

    option_cron_validate_schedule() {
        # validate whether cron job schedule consists of allowed characters
        case "${1}" in
            (*[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'!@#$%^&()_+=[]{}\|;:",.<>?']*)
                CRON_ERROR='1'
                printf " >   [!] unsupported characters\n"
                ;;
            (*)
                printf " >   [i] supported characters\n"
                ;;
        esac
        # validate whether cron job schedule consists of 5 substrings
        if [ "$(printf "%s" "${1}" | awk -F' ' '{print NF}')" -eq 5 ]; then
            printf " >   [i] supported format\n"
        else
            CRON_ERROR='1'
            printf " >   [!] unsuported format\n"
        fi
    }

    option_cron_check_configuration() {
        # first check whether a automated feature is enabled
        if [ "${1}" -ge '1' ]; then
            # then check whether the corresponding cron parameter has been set in serverbot.conf
            if [ "${2}" -eq '1' ]; then
                # then validate the cron parameter and report any issues
                printf " >  Validating %s (enabled)\n" "${4}"
                option_cron_validate_schedule "${3}"
            else
                # finally abort when issues are found
                printf " >  %s is not set\n" "${4}"
                program_error "${4} not set in ${SERVERBOT_CONFIGURATION}"
            fi
        else
            # skip check if feature is disabled
            printf " >  Skipping %s (disabled)\n" "${4}"
        fi
    }

    option_cron_add_job() {
        # first check whether a automated feature is enabled
        if [ "${1}" -ge '1' ]; then
            # then write cron job to the cron file if the automated feature is enabled
            printf " >  %s with cron schedule %s\n" "${5}" "${4}" 
            printf "\n%s root /usr/local/bin/serverbot --%s " "${4}" "${6}" >> "${SERVERBOT_CRONFILE}"
            # add method logger if it is enabled
            if [ "${2}" -eq '1' ]; then
                printf "%slogger " "--" >> "${SERVERBOT_CRONFILE}"
            fi
            # add method telegram if it is enabled
            if [ "${3}" -eq '1' ]; then
                printf "%stelegram " "--" >> "${SERVERBOT_CRONFILE}"
            fi
        fi
    }

    # cronjob creation will only work when the cron variables are set in serverbot.conf
    printf "[0] Check whether serverbot.conf exists\n"
    if [ -f "${SERVERBOT_CONFIGURATION}" ]; then
        printf " >  found %s\n" "${SERVERBOT_CONFIGURATION}"
    else
        printf " >  %s does not exist, aborting\n" "${SERVERBOT_CONFIGURATION}"
        program_error "automated cronjob creation requires the ${SERVERBOT_CONFIGURATION} configuration file with the FEATURE_CRON variable(s) set"
    fi
    # check each feature's configuration and validate cron job schedule
    printf "[1] Checking cron configuration validity\n"
    option_cron_check_configuration "${AUTOMATED_SUMMARY_TASKS_COMBINED}" "${CONFIG_SUMMARY_CRON}" "${SUMMARY_CRON}" "SUMMARY_CRON"
    option_cron_check_configuration "${AUTOMATED_OVERVIEW_TASKS_COMBINED}" "${CONFIG_OVERVIEW_CRON}" "${OVERVIEW_CRON}" "OVERVIEW_CRON"
    option_cron_check_configuration "${AUTOMATED_ALERT_TASKS_COMBINED}" "${CONFIG_ALERT_CRON}" "${ALERT_CRON}" "ALERT_CRON"
    option_cron_check_configuration "${AUTOMATED_BASEUPDATES_TASKS_COMBINED}" "${CONFIG_BASEUPDATES_CRON}" "${BASE_UPDATES_CRON}" "BASEUPDATES_CRON"
    option_cron_check_configuration "${AUTOMATED_PKGUPDATES_TASKS_COMBINED}" "${CONFIG_PKGUPDATES_CRON}" "${PKG_UPDATES_CRON}" "SUMMARY_CRON"
    option_cron_check_configuration "${AUTOMATED_PKGAUDIT_TASKS_COMBINED}" "${CONFIG_PKGAUDIT_CRON}" "${PKG_AUDIT_CRON}" "PKGAUDIT_CRON"
    option_cron_check_configuration "${AUTOMATED_PKGCHECKSUM_TASKS_COMBINED}" "${CONFIG_PKGCHECKSUM_CRON}" "${PKG_CHECKSUM_CRON}" "PKGCHECKSUM_CRON"
    # abort option cron when a cron job schedule error has been found
    if [ "${CRON_ERROR}" = '1' ]; then
        program_error 'cron configuration must be valid'
    else
        printf " >  All CRON entries in %s are valid\n" "${SERVERBOT_CONFIGURATION}"
    fi
    # old cronjob file can only be removed when it exists
    printf "[2] Removing old serverbot cronjob\n"
    if [ -f "${SERVERBOT_CRONFILE}" ]; then
        rm -f "${SERVERBOT_CRONFILE}"
        printf " >  Done\n"
    else
        printf "    Cronjob file not found, skipping removal"
    fi
    # if there are no activated automated tasks then no automated task has to be created
    if [ "${AUTOMATED_TASKS_COMBINED}" -eq '0' ]; then
        printf "[3] No automated tasks to add\n"
        printf " >  All done!\n"
    else
        # add cronjob for each activated automated task 
        printf "[3] Adding configured automated tasks for features:\n"
        printf "# This cronjob manages automated serverbot features\n" > "${SERVERBOT_CRONFILE}"
        option_cron_add_job "${AUTOMATED_SUMMARY_TASKS_COMBINED}" "${CONFIG_SUMMARY_LOGGER}" "${CONFIG_SUMMARY_TELEGRAM}" "${SUMMARY_CRON}" "SUMMARY    " "summary"
        option_cron_add_job "${AUTOMATED_OVERVIEW_TASKS_COMBINED}" "${CONFIG_OVERVIEW_LOGGER}" "${CONFIG_OVERVIEW_TELEGRAM}" "${OVERVIEW_CRON}" "OVERVIEW   " "overview"
        option_cron_add_job "${AUTOMATED_ALERT_TASKS_COMBINED}" "${CONFIG_ALERT_LOGGER}" "${CONFIG_ALERT_TELEGRAM}" "${ALERT_CRON}" "ALERT      " "alert"
        option_cron_add_job "${AUTOMATED_BASEUPDATES_TASKS_COMBINED}" "${CONFIG_BASEUPDATES_LOGGER}" "${CONFIG_BASEUPDATES_TELEGRAM}" "${BASE_UPDATES_CRON}" "BASEUPDATES" "baseupdates"
        option_cron_add_job "${AUTOMATED_PKGUPDATES_TASKS_COMBINED}" "${CONFIG_PKGUPDATES_LOGGER}" "${CONFIG_PKGUPDATES_TELEGRAM}" "${PKG_UPDATES_CRON}" "PKGUPDATES " "pkgupdates"
        option_cron_add_job "${AUTOMATED_PKGAUDIT_TASKS_COMBINED}" "${CONFIG_PKGAUDIT_LOGGER}" "${CONFIG_PKGAUDIT_TELEGRAM}" "${PKG_AUDIT_CRON}" "PKGAUDIT   " "pkgaudit"
        option_cron_add_job "${AUTOMATED_PKGCHECKSUM_TASKS_COMBINED}" "${CONFIG_PKGCHECKSUM_LOGGER}" "${CONFIG_PKGCHECKSUM_TELEGRAM}" "${PKG_CHECKSUM_CRON}" "PKGCHECKSUM" "pkgchecksum"
        # add some empty lines to the end
        printf " \n\n" >> "${SERVERBOT_CRONFILE}"
        # change ownership of cronjob file so users without administrative privileges cannot edit it
        printf "[4] Changing cronjob file owner and group to root:wheel\n"
        chown root:wheel "${SERVERBOT_CRONFILE}"
        printf " >  Done\n"
        printf "[5] Changing cronjob file permissions to 555\n"
        chmod 555 "${SERVERBOT_CRONFILE}"
        printf " >  Done\n"
        printf "\nAll done! The new schedule can be found in %s.\n" "${SERVERBOT_CRONFILE}"
    fi
    exit 0
}

####################################################################################################
# CONVERT FUNCTIONS
####################################################################################################

convert_bytes_to_human_readable_memory() {
    # this function converts $1 (amount of bytes) to a human readable format based on lower and upper limits
    MEMORY_B_LOW='1'                      # byte lower limit is '1', otherwise report '0'
    MEMORY_B_HIGH='9999'                  # byte upper limit is '9.999' bytes
    MEMORY_KB_LOW='10000'                 # kilobytes will be used starting at 10 kilobytes
    MEMORY_KB_HIGH='9999999'              # kilobytes upper limit is '999.999' bytes
    MEMORY_MB_LOW='10000000'              # megabytes will be used starting at 10 megabytes
    MEMORY_MB_HIGH='9999999999'           # megabytes upper limit is '999.999.999' bytes
    MEMORY_GB_LOW='10000000000'           # gigabytes will be used starting at 10 gigabytes
    MEMORY_GB_HIGH='9999999999999'        # gigabytes upper limit is '999.999.999.999' bytes
    MEMORY_TB_LOW='10000000000000'        # terabytes will be used starting at 10 terabytes
    MEMORY_TB_HIGH='9999999999999999'     # terabytes upper limit is '999.999.999.999.999 bytes
    MEMORY_PB_LOW='10000000000000000'     # petabytes will be used starting at 10 petabytes
    #MEMORY_PB_HIGH=''                     # there is no upper limit for terabytes

    # a decimal multiplier of 1000 is used for the following unit prefixes:
    # B = byte, KB = kilobyte, MB = megabyte, GB = gigabyte, TB = terabyte, PB = petabyte
    if [ "$1" -eq '0' ]; then
        MEMORY_VIEW='0 B'
    elif [ "$1" -gt "${MEMORY_B_LOW}" ] && [ "$1" -le "${MEMORY_B_HIGH}" ]; then
        MEMORY_VIEW="$1 B"
    elif [ "$1" -gt "${MEMORY_KB_LOW}" ] && [ "$1" -le "${MEMORY_KB_HIGH}" ]; then
        MEMORY_VIEW="$(($1 / 1000)) KB"
    elif [ "$1" -gt "${MEMORY_MB_LOW}" ] && [ "$1" -le "${MEMORY_MB_HIGH}" ]; then
        MEMORY_VIEW="$(($1 / (1000 * 1000))) MB"
    elif [ "$1" -gt "${MEMORY_GB_LOW}" ] && [ "$1" -le "${MEMORY_GB_HIGH}" ]; then
        MEMORY_VIEW="$(($1 / (1000 * 1000 * 1000))) GB"
    elif [ "$1" -gt "${MEMORY_TB_LOW}" ] && [ "$1" -le "${MEMORY_TB_HIGH}" ]; then
        MEMORY_VIEW="$(($1 / (1000 * 1000 * 1000 * 1000))) TB"
    elif [ "$1" -gt "${MEMORY_PB_LOW}" ]; then
        MEMORY_VIEW="$(($1 / (1000 * 1000 * 1000 * 1000 * 1000))) PB"
    fi
}

convert_bytes_to_human_readable_disk() {
    # this function converts $1 (amount of bytes) to a human readable format based on lower and upper limits
    DISK_B_LOW='1'                      # byte lower limit is '1', otherwise report '0'
    DISK_B_HIGH='9999'                  # byte upper limit is '9.999' bytes
    DISK_KB_LOW='10000'                 # kilobytes will be used starting at 10 kilobytes
    DISK_KB_HIGH='9999999'              # kilobytes upper limit is '999.999' bytes
    DISK_MB_LOW='10000000'              # megabytes will be used starting at 10 megabytes
    DISK_MB_HIGH='9999999999'           # megabytes upper limit is '999.999.999' bytes
    DISK_GB_LOW='10000000000'           # gigabytes will be used starting at 10 gigabytes
    DISK_GB_HIGH='9999999999999'        # gigabytes upper limit is '999.999.999.999' bytes
    DISK_TB_LOW='10000000000000'        # terabytes will be used starting at 10 terabytes
    DISK_TB_HIGH='9999999999999999'     # terabytes upper limit is '999.999.999.999.999 bytes
    DISK_PB_LOW='10000000000000000'     # petabytes will be used starting at 10 petabytes
    #DISK_PB_HIGH=''                     # there is no upper limit for terabytes

    # a decimal multiplier of 1000 is used for the following unit prefixes:
    # B = byte, KB = kilobyte, MB = megabyte, GB = gigabyte, TB = terabyte, PB = petabyte
    if [ "$1" -eq '0' ]; then
        ROOT_PARTITION_VIEW='0 B'
    elif [ "$1" -gt "${DISK_B_LOW}" ] && [ "$1" -le "${DISK_B_HIGH}" ]; then
        ROOT_PARTITION_VIEW="$1 B"
    elif [ "$1" -gt "${DISK_KB_LOW}" ] && [ "$1" -le "${DISK_KB_HIGH}" ]; then
        ROOT_PARTITION_VIEW="$(($1 / 1000)) KB"
    elif [ "$1" -gt "${DISK_MB_LOW}" ] && [ "$1" -le "${DISK_MB_HIGH}" ]; then
        ROOT_PARTITION_VIEW="$(($1 / (1000 * 1000))) MB"
    elif [ "$1" -gt "${DISK_GB_LOW}" ] && [ "$1" -le "${DISK_GB_HIGH}" ]; then
        ROOT_PARTITION_VIEW="$(($1 / (1000 * 1000 * 1000))) GB"
    elif [ "$1" -gt "${DISK_TB_LOW}" ] && [ "$1" -le "${DISK_TB_HIGH}" ]; then
        ROOT_PARTITION_VIEW="$(($1 / (1000 * 1000 * 1000 * 1000))) TB"
    elif [ "$1" -gt "${DISK_PB_LOW}" ]; then
        ROOT_PARTITION_VIEW="$(($1 / (1000 * 1000 * 1000 * 1000 * 1000))) PB"
    fi
}

####################################################################################################
# GATHER FUNCTIONS
####################################################################################################

gather_information_server() {
    # gather specific system information for finer control over the method messages
    # jails don't have kernels and freebsd-update -k will give an error
    if [ "$(sysctl -n security.jail.jailed)" = '0' ]; then
        FREEBSD_INSTALLED_VERSION="$(freebsd-version -k)"
    elif [ "$(sysctl -n security.jail.jailed)" = '1' ]; then
        FREEBSD_INSTALLED_VERSION='this is a jail'
    fi
    FREEBSD_RUNNING_VERSION="$(freebsd-version -r)"
    FREEBSD_USERLAND_VERSION="$(freebsd-version -u)"
    HOSTNAME="$(uname -n)"
    OPERATING_SYSTEM="$(uname -o)"
    ARCHITECTURE="$(uname -m)"
}

gather_metrics_uptime() {
    # determine single or plural for time units
    gather_metrics_uptime_check_days() {
        if [ "${UPTIME_DAY}" -eq '1' ]; then
            DAY="${UPTIME_DAY} day"
        else
            DAY="${UPTIME_DAY} days"
        fi
    }

    gather_metrics_uptime_check_hours() {
        if [ "${UPTIME_HOUR}" -eq '1' ]; then
            HOUR="${UPTIME_HOUR} hour"
        else
            HOUR="${UPTIME_HOUR} hours"
        fi
    }

    gather_metrics_uptime_check_minutes() {
        if [ "${UPTIME_MIN}" -eq '1' ]; then
            MIN="${UPTIME_MIN} minute"
        else
            MIN="${UPTIME_MIN} minutes"
        fi
    }

    gather_metrics_uptime_check_seconds() {
        if [ "${UPTIME_SEC}" -eq '1' ]; then
            SEC="${UPTIME_SEC} second"
        else
            SEC="${UPTIME_SEC} seconds"
        fi
    }

    # freebsd's uptime command is inflexible so serverbot generates its own uptime metrics from epoch
    EPOCH_TIME="$(date +%s)"
    EPOCH_UPTIME="$(sysctl kern.boottime | awk '{printf $5}' | tr -d ',')"
    UPTIME_CALC="$((EPOCH_TIME-EPOCH_UPTIME))"
    UPTIME_DAY="$((UPTIME_CALC/86400))"
    UPTIME_DAY_ROUNDED="$((UPTIME_DAY*86400))"
    UPTIME_HOUR="$(((UPTIME_CALC-UPTIME_DAY_ROUNDED)/3600))"
    UPTIME_HOUR_ROUNDED="$((UPTIME_HOUR*3600))"
    UPTIME_MIN="$(((UPTIME_CALC-UPTIME_DAY_ROUNDED-UPTIME_HOUR_ROUNDED)/60))"
    UPTIME_MIN_ROUNDED="$((UPTIME_MIN*60))"
    UPTIME_SEC="$(((UPTIME_CALC-UPTIME_DAY_ROUNDED-UPTIME_HOUR_ROUNDED)-UPTIME_MIN_ROUNDED))"
    if [ "${UPTIME_DAY}" -ge '1' ]; then
        gather_metrics_uptime_check_days
        gather_metrics_uptime_check_hours
        gather_metrics_uptime_check_minutes
        gather_metrics_uptime_check_seconds
        UPTIME_MESSAGE="${DAY} ${HOUR} ${MIN} ${SEC}"
    elif [ "${UPTIME_HOUR}" -ge '1' ]; then
        gather_metrics_uptime_check_hours
        gather_metrics_uptime_check_minutes
        gather_metrics_uptime_check_seconds
        UPTIME_MESSAGE="${HOUR} ${MIN} ${SEC}"
    elif [ "${UPTIME_MIN}" -ge '1' ]; then
        gather_metrics_uptime_check_minutes
        gather_metrics_uptime_check_seconds
        UPTIME_MESSAGE="${MIN} ${SEC}"
    elif [ "${UPTIME_SEC}" -ge '1' ]; then
        gather_metrics_uptime_check_seconds
        UPTIME_MESSAGE="${SEC}"
    fi
}

gather_metrics_cpu() {
    # CPU_TOTAL_CORES is based on the number of threads available to the operating system
    # this can be misleading since simultaneous multithreading (SMT) effectively doubles the amount of
    # threads available to the operating system, while providing only a fraction of the performance
    # of a real physical CPU core
    # SMT provides a efficiency boost at best, but with that in mind they can still be useful
    # you can set SMT_ENABLE in serverbot.conf to 'YES' if you want serverbot to halve the amount of available threads
    if [ "${CONFIG_SMT_ENABLE}" = '1' ]; then
        CPU_TOTAL_CORES="$(($(sysctl -n hw.ncpu) / 2))"
    else
        CPU_TOTAL_CORES="$(sysctl -n hw.ncpu)"
    fi
    # create variable with maximum load based on total CPU core count
    #CPU_MAXIMUM_LOAD="${CPU_TOTAL_CORES}.00"
    # making calculations with the load metrics is easier this way
    CPU_MAXIMUM_LOAD_CALC="${CPU_TOTAL_CORES}00"

    # system load average is calculated over respectively 1, 5 and 15 minutes.
    # a load average of 1.00 means that one CPU core is working 100% of the time
    # a load average of 2.00 means that two CPU cores can be saturated fully
    # with a load average of 2.00, a single core CPU would be overloaded by 100%
    # when overloaded, processes will have to wait on each other
    CPU_LOAD_AVERAGE_1MIN="$(sysctl -n vm.loadavg | tr -d '{}' | awk '{printf $1}')"
    CPU_LOAD_AVERAGE_5MIN="$(sysctl -n vm.loadavg | tr -d '{}' | awk '{printf $2}')"
    CPU_LOAD_AVERAGE_15MIN="$(sysctl -n vm.loadavg | tr -d '{}' | awk '{printf $3}')"
    # remove dots and one or two leading zeros from 'x.xx' load
    CPU_LOAD_AVERAGE_1MIN_CALC="$(echo "${CPU_LOAD_AVERAGE_1MIN}" | tr -d '.' | sed 's/^0//' | sed 's/^0//')"
    CPU_LOAD_AVERAGE_5MIN_CALC="$(echo "${CPU_LOAD_AVERAGE_5MIN}" | tr -d '.' | sed 's/^0//' | sed 's/^0//')"
    CPU_LOAD_AVERAGE_15MIN_CALC="$(echo "${CPU_LOAD_AVERAGE_15MIN}" | tr -d '.' | sed 's/^0//' | sed 's/^0//')"
    CPU_LOAD_PERCENTAGE_1MIN="$((100*CPU_LOAD_AVERAGE_1MIN_CALC/CPU_MAXIMUM_LOAD_CALC))"
    CPU_LOAD_PERCENTAGE_5MIN="$((100*CPU_LOAD_AVERAGE_5MIN_CALC/CPU_MAXIMUM_LOAD_CALC))"
    CPU_LOAD_PERCENTAGE_15MIN="$((100*CPU_LOAD_AVERAGE_15MIN_CALC/CPU_MAXIMUM_LOAD_CALC))"

    # one load average percentage will be used for reporting/alerting purposes
    # the load average interval can be configured by setting the LOAD_INTERVAL variable in serverbot.conf
    # '15' minutes is the default
    if [ "${CONFIG_LOAD_INTERVAL}" = '1' ]; then
        CPU_LOAD_PERCENTAGE="${CPU_LOAD_PERCENTAGE_1MIN}"
    elif [ "${CONFIG_LOAD_INTERVAL}" = '5' ]; then
        CPU_LOAD_PERCENTAGE="${CPU_LOAD_PERCENTAGE_5MIN}"
    elif [ "${CONFIG_LOAD_INTERVAL}" = '15' ]; then
        CPU_LOAD_PERCENTAGE="${CPU_LOAD_PERCENTAGE_15MIN}"
    else
        CPU_LOAD_PERCENTAGE="${CPU_LOAD_PERCENTAGE_15MIN}"
    fi
}

gather_metrics_memory() {
    # this function gathers memory metrics with a lot of help from sysctl. every $MEMORY_*_COUNT
    # consists of the amount of memory pages used. Each memory page consists of $MEMORY_PAGE_SIZE
    # amount of bytes

    # a decimal multiplier of 1000 is used for the following unit prefixes:
    # B = byte, KB = kilobyte, MB = megabyte, GB = gigabyte, TB = terabyte

    # page size: amount of memory (in bytes) reported by the firmware.
    MEMORY_PAGE_SIZE="$(sysctl -n hw.pagesize)"

    # hw.physman:  amount of physical memory (in bytes) minus kernel and pre-loaded modules
    # hw.usermem:  amount of memory (in bytes) which is not wired.
    # hw.realmem: 
    #MEMORY_TOTAL_PHYSICAL_B="$(sysctl -n hw.physmem)"
    #MEMORY_TOTAL_USER_B="$(sysctl -n hw.usermem)"
    #MEMORY_TOTAL_REAL_B="$(sysctl -n hw.realmem)"

    # active:    contains active (recently referenced) pages
    # inactive:  contains inactive pages that are aged out of the active queue
    # laundry:   queue for managing dirty inactive pages which must be cleaned
    # wired:     non-pageable memory that cannot be freed unless released by the owner
    # free:      contains available memory for use by the system
    MEMORY_ACTIVE_COUNT="$(sysctl -n vm.stats.vm.v_active_count)"
    MEMORY_ACTIVE_B="$((MEMORY_ACTIVE_COUNT * MEMORY_PAGE_SIZE))"
    MEMORY_INACTIVE_COUNT="$(sysctl -n vm.stats.vm.v_inactive_count)"
    MEMORY_INACTIVE_B="$((MEMORY_INACTIVE_COUNT * MEMORY_PAGE_SIZE))"
    MEMORY_LAUNDRY_COUNT="$(sysctl -n vm.stats.vm.v_laundry_count)"
    MEMORY_LAUNDRY_B="$((MEMORY_LAUNDRY_COUNT * MEMORY_PAGE_SIZE))"
    MEMORY_WIRED_COUNT="$(sysctl -n vm.stats.vm.v_wire_count)"
    MEMORY_WIRED_B="$((MEMORY_WIRED_COUNT * MEMORY_PAGE_SIZE))"
    MEMORY_WIRED_ARC_B="$(sysctl -n kstat.zfs.misc.arcstats.size)"
    MEMORY_WIRED_KERNEL_B="$((MEMORY_WIRED_B - MEMORY_WIRED_ARC_B))"
    MEMORY_CACHE_COUNT="$(sysctl -n vm.stats.vm.v_cache_count)"
    MEMORY_CACHE_B="$((MEMORY_CACHE_COUNT * MEMORY_PAGE_SIZE))"
    MEMORY_FREE_COUNT="$(sysctl -n vm.stats.vm.v_free_count)"
    MEMORY_FREE_B="$((MEMORY_FREE_COUNT * MEMORY_PAGE_SIZE))"

    # used memory:        equal to active and wired memory combined
    # used noarc memory:  equal to used memory minus the zfs arc cache
    # unused memory:      equal to inactive and free memory combined
    # total memory:       equal to active, inactive, laundry, wired, cache and free memory combined
    MEMORY_USED_COUNT="$((MEMORY_ACTIVE_COUNT + MEMORY_WIRED_COUNT))"
    MEMORY_USED_B="$((MEMORY_USED_COUNT * MEMORY_PAGE_SIZE))"
    MEMORY_USED_NOARC_B="$((MEMORY_USED_B - MEMORY_WIRED_ARC_B))"
    MEMORY_UNUSED_COUNT="$((MEMORY_INACTIVE_COUNT + MEMORY_FREE_COUNT))"
    MEMORY_UNUSED_B="$((MEMORY_UNUSED_COUNT * MEMORY_PAGE_SIZE))"
    MEMORY_UNUSED_ARC_B="$((MEMORY_UNUSED_B + MEMORY_WIRED_ARC_B))"
    MEMORY_TOTAL_COUNT="$((MEMORY_ACTIVE_COUNT + MEMORY_INACTIVE_COUNT + MEMORY_LAUNDRY_COUNT + MEMORY_WIRED_COUNT + MEMORY_CACHE_COUNT + MEMORY_FREE_COUNT))"
    MEMORY_TOTAL_B="$((MEMORY_TOTAL_COUNT * MEMORY_PAGE_SIZE))"

    # calculate percentages for reporting purposes
    MEMORY_ACTIVE_PERCENTAGE="$((100 * MEMORY_ACTIVE_COUNT / MEMORY_TOTAL_COUNT))"
    MEMORY_INACTIVE_PERCENTAGE="$((100 * MEMORY_INACTIVE_COUNT / MEMORY_TOTAL_COUNT))"
    MEMORY_LAUNDRY_PERCENTAGE="$((100 * MEMORY_LAUNDRY_COUNT / MEMORY_TOTAL_COUNT))"
    MEMORY_WIRED_PERCENTAGE="$((100 * MEMORY_WIRED_COUNT / MEMORY_TOTAL_COUNT))"
    MEMORY_WIRED_ARC_PERCENTAGE="$((100 * MEMORY_WIRED_ARC_B / MEMORY_TOTAL_B))"
    MEMORY_WIRED_KERNEL_PERCENTAGE="$((100 * MEMORY_WIRED_KERNEL_B / MEMORY_TOTAL_B))"
    MEMORY_CACHE_PERCENTAGE="$((100 * MEMORY_CACHE_COUNT / MEMORY_TOTAL_COUNT))"
    MEMORY_FREE_PERCENTAGE="$((100 * MEMORY_FREE_COUNT / MEMORY_TOTAL_COUNT))"
    MEMORY_USED_PERCENTAGE="$((100 * MEMORY_USED_COUNT / MEMORY_TOTAL_COUNT))"
    MEMORY_USED_NOARC_PERCENTAGE="$((100 * MEMORY_USED_NOARC_B / MEMORY_TOTAL_B))"
    #MEMORY_UNUSED_PERCENTAGE="$((100 * MEMORY_UNUSED_COUNT / MEMORY_TOTAL_COUNT))"
    MEMORY_UNUSED_ARC_PERCENTAGE="$((100 * MEMORY_UNUSED_ARC_B / MEMORY_TOTAL_B))"
    MEMORY_TOTAL_PERCENTAGE='100'

    # only a few among us like reading amounts of memory in bytes, that's why human readable
    # unit of measures will be determined for reporting purposes
    convert_bytes_to_human_readable_memory "${MEMORY_ACTIVE_B}"
    MEMORY_ACTIVE_VIEW="${MEMORY_VIEW}"
    convert_bytes_to_human_readable_memory "${MEMORY_INACTIVE_B}"
    MEMORY_INACTIVE_VIEW="${MEMORY_VIEW}"
    convert_bytes_to_human_readable_memory "${MEMORY_LAUNDRY_B}"
    MEMORY_LAUNDRY_VIEW="${MEMORY_VIEW}"
    convert_bytes_to_human_readable_memory "${MEMORY_WIRED_B}"
    MEMORY_WIRED_VIEW="${MEMORY_VIEW}"
    convert_bytes_to_human_readable_memory "${MEMORY_WIRED_ARC_B}"
    MEMORY_WIRED_ARC_VIEW="${MEMORY_VIEW}"
    convert_bytes_to_human_readable_memory "${MEMORY_WIRED_KERNEL_B}"
    MEMORY_WIRED_KERNEL_VIEW="${MEMORY_VIEW}"
    convert_bytes_to_human_readable_memory "${MEMORY_CACHE_B}"
    MEMORY_CACHE_VIEW="${MEMORY_VIEW}"
    convert_bytes_to_human_readable_memory "${MEMORY_FREE_B}"
    MEMORY_FREE_VIEW="${MEMORY_VIEW}"
    convert_bytes_to_human_readable_memory "${MEMORY_USED_B}"
    MEMORY_USED_VIEW="${MEMORY_VIEW}"
    convert_bytes_to_human_readable_memory "${MEMORY_USED_NOARC_B}"
    MEMORY_USED_NOARC_VIEW="${MEMORY_VIEW}"
    #convert_bytes_to_human_readable_memory "${MEMORY_UNUSED_B}"
    #MEMORY_UNUSED_VIEW="${MEMORY_VIEW}"
    convert_bytes_to_human_readable_memory "${MEMORY_UNUSED_ARC_B}"
    MEMORY_UNUSED_ARC_VIEW="${MEMORY_VIEW}"
    convert_bytes_to_human_readable_memory "${MEMORY_TOTAL_B}"
    MEMORY_TOTAL_VIEW="${MEMORY_VIEW}"
}

gather_metrics_disk() {
    # df gives a misleading view on zfs pools, so zfs is configurable in serverbot.conf
    if [ "${CONFIG_ZFS_ENABLE}" = '1' ]; then
        # this function gathers root partition metrics with help from zpool
        ROOT_PARTITION_SIZE_B="$(zpool list -H -p -o size)"
        ROOT_PARTITION_USED_B="$(zpool list -H -p -o alloc)"
        ROOT_PARTITION_FREE_B="$(zpool list -H -p -o free)"
        ROOT_PARTITION_USED_PERCENTAGE="$((100 * ROOT_PARTITION_USED_B / ROOT_PARTITION_SIZE_B))"
        ROOT_PARTITION_FREE_PERCENTAGE="$((100 * ROOT_PARTITION_FREE_B / ROOT_PARTITION_SIZE_B))"
    else
        # this function gathers root partition metrics with help from df
        # posix mode is used for compatibility purposes
        ROOT_PARTITION_SIZE_512="$(df -P / | sed -n '2 p' | awk '{printf $4}')"
        ROOT_PARTITION_SIZE_B="$((ROOT_PARTITION_SIZE_512 * 512))"
        ROOT_PARTITION_USED_512="$(df -P / | sed -n '2 p' | awk '{printf $3}')"
        ROOT_PARTITION_USED_B="$((ROOT_PARTITION_USED_512 * 512))"
        ROOT_PARTITION_USED_PERCENTAGE="$((100 * ROOT_PARTITION_USED_512 / ROOT_PARTITION_SIZE_512))"
        ROOT_PARTITION_FREE_B="$((ROOT_PARTITION_SIZE_B - ROOT_PARTITION_USED_B))"
        ROOT_PARTITION_FREE_PERCENTAGE="$((100 * ROOT_PARTITION_FREE_B / ROOT_PARTITION_SIZE_B))"
    fi

    # only a few among us like reading amounts of memory in bytes, that's why human readable
    # unit of measures will be determined for reporting purposes
    convert_bytes_to_human_readable_disk "${ROOT_PARTITION_SIZE_B}"
    ROOT_PARTITION_SIZE_VIEW="${ROOT_PARTITION_VIEW}"
    convert_bytes_to_human_readable_disk "${ROOT_PARTITION_USED_B}"
    ROOT_PARTITION_USED_VIEW="${ROOT_PARTITION_VIEW}"
    convert_bytes_to_human_readable_disk "${ROOT_PARTITION_FREE_B}"
    ROOT_PARTITION_FREE_VIEW="${ROOT_PARTITION_VIEW}"
}

gather_temperature_cpu() {
    # check whether CPU manufacturer is Intel, AMD or other
    # then check whether the corresponding device driver is loaded
    # if this is not the case, then load the device driver
    if [ "$(sysctl hw.model | grep --ignore-case intel)" ]; then
        CPU_MANUFACTURER='intel'
        if ! [ "$(kldstat | grep --ignore-case coretemp)" ]; then
            kldload -n coretemp
        fi
    elif [ "$(sysctl hw.model | grep --ignore-case amd)" ]; then
        CPU_MANUFACTURER='intel'
        if ! [ "$(kldstat | grep --ignore-case amdtemp)" ]; then
            kldload -n amdtemp
        fi
    else
        CPU_MANUFACTURER='0'
    fi
    # read temperature if CPU manufacturer is supported
    if [ "${CPU_MANUFACTURER}" = 'intel' ] || [ "${CPU_MANUFACTURER}" = 'amd' ]; then
        CPU_TEMPERATURE='0'
        # iterate over CPU core temperatures and find the highest temperature value
        for temperature in $(sysctl dev.cpu | grep 'temperature' | cut -d ' ' -f2- | cut -d '.' -f1); do
            if [ "${temperature}" -gt "${CPU_TEMPERATURE}" ]; then
                CPU_TEMPERATURE="${temperature}"
            fi
        done
    # disable CPU temperature alert if CPU manufacturer is not supported
    elif [ "${CPU_MANUFACTURER}" = '0' ]; then
        DISABLE_ALERT_CPUTEMP='1'
    fi
}

gather_updates_base() {
    # freebsd-update cron sleeps netween 1 and 3600 seconds by default
    freebsd-update cron
    freebsd-update updatesready > /dev/null
    # freebsd-update updatesready returns exit code 2 if there are no patches
    if [ "${?}" -eq '2' ]; then
        UPDATES_BASE='0'
    else
        UPDATES_BASE='1'
    fi
}

gather_updates_pkg() {
    # update package database silently
    pkg update --force --quiet
    # only grep packages that can be upgraded and remove the '<'
    UPDATES_PKG="$(pkg version | grep "<" | tr -d "\<")"
}

gather_audit_pkg() {
    # audit packages silently
    AUDIT_PKG="$(pkg audit --fetch --quiet)"
}

gather_checksum_pkg() {
    # for some reason pkg check writes its output to stderr
    CHECKSUM_PKG="$(pkg check --checksums --all --quiet 2>&1)"
}

####################################################################################################
# FEATURE FUNCTIONS
####################################################################################################

# each feature has its own function and each function contains all available methods
# multiple methods can be used simultaneously, but only one feature can be used at a time
# the user is notified when a specific method isn't supported for a specific feature

feature_basic() {
    gather_information_server

    if [ "${ARGUMENT_BASIC}" = '1' ] && [ "${ARGUMENT_CLI}" = '1' ]; then
        printf "%s\n" "${HOSTNAME}"
        printf "%s\n" "${OPERATING_SYSTEM} ${FREEBSD_INSTALLED_VERSION} (${ARCHITECTURE})"
    fi
    if [ "${ARGUMENT_BASIC}" = '1' ] && [ "${ARGUMENT_LOGGER}" = '1' ]; then
        method_logger "${HOSTNAME}"
        method_logger "${OPERATING_SYSTEM} ${FREEBSD_INSTALLED_VERSION} (${ARCHITECTURE})"
    fi
    if [ "${ARGUMENT_BASIC}" = '1' ] && [ "${ARGUMENT_TELEGRAM}" = '1' ]; then
        TELEGRAM_MESSAGE="$(printf "<b>Hostname:</b>                  <code>%s</code>\\n<b>os/kernel</b>:                    <code>%s %s (%s)</code>" "${HOSTNAME}" "${OPERATING_SYSTEM}" "${FREEBSD_INSTALLED_VERSION}" "${ARCHITECTURE}")"
        method_telegram
    fi
    exit 0
}

feature_summary() {
    gather_information_server
    gather_metrics_cpu
    gather_metrics_memory
    gather_metrics_disk

    if [ "${ARGUMENT_SUMMARY}" = '1' ] && [ "${ARGUMENT_CLI}" = '1' ]; then
        printf "%-9s %9s %1s %7s %4s%0s%0s%0s\n" "load" "${CPU_LOAD_AVERAGE_15MIN}" "" "" "(" "${CPU_LOAD_PERCENTAGE_15MIN}" "%" ")"
        printf "%-9s %9s %1s %7s %4s%0s%0s%0s\n" "memory" "${MEMORY_USED_NOARC_VIEW}" "/" "${MEMORY_TOTAL_VIEW}" "(" "${MEMORY_USED_NOARC_PERCENTAGE}" "%" ")"
        printf "%-9s %9s %1s %7s %4s%0s%0s%0s\n" "disk" "${ROOT_PARTITION_USED_VIEW}" "/" "${ROOT_PARTITION_SIZE_VIEW}" "(" "${ROOT_PARTITION_USED_PERCENTAGE}" "%" ")"
    fi
    if [ "${ARGUMENT_SUMMARY}" = '1' ] && [ "${ARGUMENT_LOGGER}" = '1' ]; then
        method_logger "load ${CPU_LOAD_AVERAGE_15MIN} (${CPU_LOAD_PERCENTAGE_15MIN}%)"
        method_logger "memory ${MEMORY_USED_NOARC_VIEW} / ${MEMORY_TOTAL_VIEW} (${MEMORY_USED_NOARC_PERCENTAGE}%)"
        method_logger "disk ${ROOT_PARTITION_USED_VIEW} / ${ROOT_PARTITION_SIZE_VIEW} (${ROOT_PARTITION_USED_PERCENTAGE}%)"
    fi
    if [ "${ARGUMENT_SUMMARY}" = '1' ] && [ "${ARGUMENT_TELEGRAM}" = '1' ]; then
        TELEGRAM_MESSAGE="$(printf "<b>hostname:</b>                  <code>%s</code>\\n<b>cpu load:</b>                     <code>%s (%s%%) %s (%s%%) %s (%s%%)</code>\\n<b>memory:</b>                     <code>%s (%s%%) / %s</code>\\n<b>disk:</b>                              <code>${ROOT_PARTITION_USED_VIEW} (${ROOT_PARTITION_USED_PERCENTAGE}%%) / ${ROOT_PARTITION_SIZE_VIEW}</code>" "${HOSTNAME}" "${CPU_LOAD_AVERAGE_1MIN}" "${CPU_LOAD_PERCENTAGE_1MIN}" "${CPU_LOAD_AVERAGE_5MIN}" "${CPU_LOAD_PERCENTAGE_5MIN}" "${CPU_LOAD_AVERAGE_15MIN}" "${CPU_LOAD_PERCENTAGE_15MIN}" "${MEMORY_USED_NOARC_VIEW}" "${MEMORY_USED_NOARC_PERCENTAGE}" "${MEMORY_TOTAL_VIEW}")"
        method_telegram
    fi
    exit 0
}

feature_overview() {
    gather_information_server
    gather_metrics_uptime
    gather_metrics_cpu
    gather_metrics_memory
    gather_metrics_disk

    if [ "${ARGUMENT_OVERVIEW}" = '1' ] && [ "${ARGUMENT_CLI}" = '1' ]; then
        printf "hostname            %s\n" "${HOSTNAME}"
        printf "operating system    %s\n" "${OPERATING_SYSTEM} (${ARCHITECTURE})"
        printf "kernel (installed)  %s\n" "${FREEBSD_INSTALLED_VERSION}"
        printf "kernel (running)    %s\n" "${FREEBSD_RUNNING_VERSION}"
        printf "userland version    %s\n" "${FREEBSD_USERLAND_VERSION}"
        printf "uptime              %s\n\n" "${UPTIME_MESSAGE}"
        printf "%-14s %-14s %-16s %-16s\n" "cpu load" "1 min" "5 min" "15 min"
        printf "%-14s %-14s %-16s %-16s\n\n" "" "${CPU_LOAD_AVERAGE_1MIN} (${CPU_LOAD_PERCENTAGE_1MIN}%)" "${CPU_LOAD_AVERAGE_5MIN} (${CPU_LOAD_PERCENTAGE_5MIN}%)" "${CPU_LOAD_AVERAGE_15MIN} (${CPU_LOAD_PERCENTAGE_15MIN}%)"
        printf "%-14s %-14s %-16s %-16s\n" "memory" "total" "used" "unused"
        printf "%-14s %-14s %-16s %-16s\n\n" "" "${MEMORY_TOTAL_VIEW}" "${MEMORY_USED_NOARC_VIEW} (${MEMORY_USED_NOARC_PERCENTAGE}%)" "${MEMORY_UNUSED_ARC_VIEW} (${MEMORY_UNUSED_ARC_PERCENTAGE}%)"
        printf "%-14s %-14s %-16s %-16s\n" "disk usage" "total" "used" "free"
        printf "%-14s %-14s %-16s %-16s\n" "" "${ROOT_PARTITION_SIZE_VIEW}" "${ROOT_PARTITION_USED_VIEW} (${ROOT_PARTITION_USED_PERCENTAGE}%)" "${ROOT_PARTITION_FREE_VIEW} (${ROOT_PARTITION_FREE_PERCENTAGE}%)"
    fi
    if [ "${ARGUMENT_OVERVIEW}" = '1' ] && [ "${ARGUMENT_LOGGER}" = '1' ]; then
        method_logger "hostname: ${HOSTNAME}"
        method_logger "operating system: ${OPERATING_SYSTEM} (${ARCHITECTURE})"
        method_logger "kernel (installed): ${FREEBSD_INSTALLED_VERSION}"
        method_logger "kernel (running): ${FREEBSD_RUNNING_VERSION}"
        method_logger "userland version: ${FREEBSD_USERLAND_VERSION}"
        method_logger "uptime: ${UPTIME_MESSAGE}"
        method_logger "cpu load (1/5/15 min): ${CPU_LOAD_AVERAGE_1MIN} (${CPU_LOAD_PERCENTAGE_1MIN}%) / ${CPU_LOAD_AVERAGE_5MIN} (${CPU_LOAD_PERCENTAGE_5MIN}%) / ${CPU_LOAD_AVERAGE_15MIN} (${CPU_LOAD_PERCENTAGE_15MIN}%)"
        method_logger "memory (total|used/unused): ${MEMORY_TOTAL_VIEW} | ${MEMORY_USED_NOARC_VIEW} (${MEMORY_USED_NOARC_PERCENTAGE}%) / ${MEMORY_UNUSED_ARC_VIEW} (${MEMORY_UNUSED_ARC_PERCENTAGE}%)"
        method_logger "disk usage (total|used/unused): ${ROOT_PARTITION_SIZE_VIEW} | ${ROOT_PARTITION_USED_VIEW} (${ROOT_PARTITION_USED_PERCENTAGE}%) / ${ROOT_PARTITION_FREE_VIEW} (${ROOT_PARTITION_FREE_PERCENTAGE}%)"
    fi
    if [ "${ARGUMENT_OVERVIEW}" = '1' ] && [ "${ARGUMENT_TELEGRAM}" = '1' ]; then
        TELEGRAM_MESSAGE="$(printf "<b>hostname:</b>                    <code>%s</code>\\n<b>operating system</b>:     <code>%s (%s)</code>\\n<b>kernel (installed)</b>:      <code>%s</code>\\n<b>kernel (running)</b>:        <code>%s</code>\\n<b>userland version</b>:      <code>%s</code>\\n<b>uptime:</b>                          <code>%s</code>\\n<b>cpu load:</b>                       <code>%s (%s%%) %s (%s%%) %s (%s%%)</code>\\n<b>memory:</b>                       <code>%s (%s%%) / %s</code>\\n<b>disk:</b>                                <code>%s (%s%%) / %s</code>" "${HOSTNAME}" "${OPERATING_SYSTEM}" "${ARCHITECTURE}" "${FREEBSD_INSTALLED_VERSION}" "${FREEBSD_RUNNING_VERSION}" "${FREEBSD_USERLAND_VERSION}" "${UPTIME_MESSAGE}" "${CPU_LOAD_AVERAGE_1MIN}" "${CPU_LOAD_PERCENTAGE_1MIN}" "${CPU_LOAD_AVERAGE_5MIN}" "${CPU_LOAD_PERCENTAGE_5MIN}" "${CPU_LOAD_AVERAGE_15MIN}" "${CPU_LOAD_PERCENTAGE_15MIN}" "${MEMORY_USED_NOARC_VIEW}" "${MEMORY_USED_NOARC_PERCENTAGE}" "${MEMORY_TOTAL_VIEW}" "${ROOT_PARTITION_USED_VIEW}" "${ROOT_PARTITION_USED_PERCENTAGE}" "${ROOT_PARTITION_SIZE_VIEW}")"
        method_telegram
    fi
    exit 0
}

feature_uptime() {
    gather_information_server
    gather_metrics_uptime

    if [ "${ARGUMENT_UPTIME}" = '1' ] && [ "${ARGUMENT_CLI}" = '1' ]; then
        printf "%s\n" "${UPTIME_MESSAGE}"
    fi
    if [ "${ARGUMENT_UPTIME}" = '1' ] && [ "${ARGUMENT_LOGGER}" = '1' ]; then
        method_logger "uptime: ${UPTIME_MESSAGE}"
    fi
    if [ "${ARGUMENT_UPTIME}" = '1' ] && [ "${ARGUMENT_TELEGRAM}" = '1' ]; then
        TELEGRAM_MESSAGE="$(printf "<b>hostname:</b>                  <code>%s</code>\\n<b>uptime:</b>                        <code>%s</code>" "${HOSTNAME}" "${UPTIME_MESSAGE}")"
        method_telegram
    fi
    exit 0
}

feature_cpu() {
    gather_information_server
    gather_metrics_cpu

    if [ "${ARGUMENT_CPU}" = '1' ] && [ "${ARGUMENT_CLI}" = '1' ]; then
        printf "%-14s %-14s %-16s %-16s\n" "cpu load" "1 min" "5 min" "15 min"
        printf "%-14s %-14s %-16s %-16s\n" "" "${CPU_LOAD_AVERAGE_1MIN} (${CPU_LOAD_PERCENTAGE_1MIN}%)" "${CPU_LOAD_AVERAGE_5MIN} (${CPU_LOAD_PERCENTAGE_5MIN}%)" "${CPU_LOAD_AVERAGE_15MIN} (${CPU_LOAD_PERCENTAGE_15MIN}%)"
    fi
    if [ "${ARGUMENT_CPU}" = '1' ] && [ "${ARGUMENT_LOGGER}" = '1' ]; then
        method_logger "cpu load (1/5/15 min): ${CPU_LOAD_AVERAGE_1MIN} (${CPU_LOAD_PERCENTAGE_1MIN}%) / ${CPU_LOAD_AVERAGE_5MIN} (${CPU_LOAD_PERCENTAGE_5MIN}%) / ${CPU_LOAD_AVERAGE_15MIN} (${CPU_LOAD_PERCENTAGE_15MIN}%)"
    fi
    if [ "${ARGUMENT_CPU}" = '1' ] && [ "${ARGUMENT_TELEGRAM}" = '1' ]; then
        TELEGRAM_MESSAGE="$(printf "<b>hostname:</b>                  <code>%s</code>\\n<b>cpu load:</b>                     <code>%s (%s%%) %s (%s%%) %s (%s%%)</code>" "${HOSTNAME}" "${CPU_LOAD_AVERAGE_1MIN}" "${CPU_LOAD_PERCENTAGE_1MIN}" "${CPU_LOAD_AVERAGE_5MIN}" "${CPU_LOAD_PERCENTAGE_5MIN}" "${CPU_LOAD_AVERAGE_15MIN}" "${CPU_LOAD_PERCENTAGE_15MIN}")"
        method_telegram
    fi
    exit 0
}

feature_memory() {
    gather_information_server
    gather_metrics_memory

    if [ "${ARGUMENT_MEMORY}" = '1' ] && [ "${ARGUMENT_CLI}" = '1' ]; then
        printf "%-14s %-14s %-16s %-16s\n" "memory" "total" "used" "unused"
        printf "%-14s %-14s %-16s %-16s\n" "" "${MEMORY_TOTAL_VIEW}" "${MEMORY_USED_NOARC_VIEW} (${MEMORY_USED_NOARC_PERCENTAGE}%)" "${MEMORY_UNUSED_ARC_VIEW} (${MEMORY_UNUSED_ARC_PERCENTAGE}%)"
    fi
    if [ "${ARGUMENT_MEMORY}" = '1' ] && [ "${ARGUMENT_LOGGER}" = '1' ]; then
        method_logger "memory (total|used/unused): ${MEMORY_TOTAL_VIEW} | ${MEMORY_USED_NOARC_VIEW} (${MEMORY_USED_NOARC_PERCENTAGE}%) / ${MEMORY_UNUSED_ARC_VIEW} (${MEMORY_UNUSED_ARC_PERCENTAGE}%)"
    fi
    if [ "${ARGUMENT_MEMORY}" = '1' ] && [ "${ARGUMENT_TELEGRAM}" = '1' ]; then
        TELEGRAM_MESSAGE="$(printf "<b>hostname:</b>                  <code>%s</code>\\n<b>memory:</b>                     <code>%s (%s%%) / %s</code>" "${HOSTNAME}" "${MEMORY_USED_NOARC_VIEW}" "${MEMORY_USED_NOARC_PERCENTAGE}" "${MEMORY_TOTAL_VIEW}")"
        method_telegram
    fi
    exit 0
}


feature_memorytree() {
    gather_information_server
    gather_metrics_memory

    if [ "${ARGUMENT_MEMORYTREE}" = '1' ] && [ "${ARGUMENT_CLI}" = '1' ]; then
        printf "%-19s %8s %10s\n" "Total" "${MEMORY_TOTAL_VIEW}" "${MEMORY_TOTAL_PERCENTAGE}%"
        printf "%-19s %8s %10s\n" "|- Free" "${MEMORY_FREE_VIEW}" "${MEMORY_FREE_PERCENTAGE}%"
        printf "%-19s %8s %10s\n" "|- Used" "${MEMORY_USED_VIEW}" "${MEMORY_USED_PERCENTAGE}%"
        printf "%-19s %8s %10s\n" "   |- Active" "${MEMORY_ACTIVE_VIEW}" "${MEMORY_ACTIVE_PERCENTAGE}%"
        printf "%-19s %8s %10s\n" "   \`- Wired" "${MEMORY_WIRED_VIEW}" "${MEMORY_WIRED_PERCENTAGE}%"
        printf "%-19s %8s %10s\n" "      |- Kernel" "${MEMORY_WIRED_KERNEL_VIEW}" "${MEMORY_WIRED_KERNEL_PERCENTAGE}%"
        printf "%-19s %8s %10s\n" "      \`- Arc" "${MEMORY_WIRED_ARC_VIEW}" "${MEMORY_WIRED_ARC_PERCENTAGE}%"
        printf "%-19s %8s %10s\n" "|- Inactive" "${MEMORY_INACTIVE_VIEW}" "${MEMORY_INACTIVE_PERCENTAGE}%"
        printf "%-19s %8s %10s\n" "|- Laundry" "${MEMORY_LAUNDRY_VIEW}" "${MEMORY_LAUNDRY_PERCENTAGE}%"
        printf "%-19s %8s %10s\n" "\`- Cache" "${MEMORY_CACHE_VIEW}" "${MEMORY_CACHE_PERCENTAGE}%"
    fi
    if [ "${ARGUMENT_MEMORYTREE}" = '1' ] && [ "${ARGUMENT_LOGGER}" = '1' ]; then
        method_logger 'the logger method is not supported for feature memorytree'
    fi
    if [ "${ARGUMENT_MEMORYTREE}" = '1' ] && [ "${ARGUMENT_TELEGRAM}" = '1' ]; then
        TELEGRAM_MESSAGE="$(printf "<b>hostname:</b>            <code>%s</code>\\n<b>error:</b>                      <code>serverbot: memorytree doesn't support telegram</code>" "${HOSTNAME}")"
        method_telegram
    fi
    exit 0
}

feature_disk() {
    gather_information_server
    gather_metrics_disk

    if [ "${ARGUMENT_DISK}" = '1' ] && [ "${ARGUMENT_CLI}" = '1' ]; then
        printf "%-14s %-14s %-16s %-16s\n" "disk usage" "total" "used" "free"
        printf "%-14s %-14s %-16s %-16s\n" "" "${ROOT_PARTITION_SIZE_VIEW}" "${ROOT_PARTITION_USED_VIEW} (${ROOT_PARTITION_USED_PERCENTAGE}%)" "${ROOT_PARTITION_FREE_VIEW} (${ROOT_PARTITION_FREE_PERCENTAGE}%)"
    fi
    if [ "${ARGUMENT_DISK}" = '1' ] && [ "${ARGUMENT_LOGGER}" = '1' ]; then
        method_logger "disk usage (total|used/unused): ${ROOT_PARTITION_SIZE_VIEW} | ${ROOT_PARTITION_USED_VIEW} (${ROOT_PARTITION_USED_PERCENTAGE}%) / ${ROOT_PARTITION_FREE_VIEW} (${ROOT_PARTITION_FREE_PERCENTAGE}%)"
    fi
    if [ "${ARGUMENT_DISK}" = '1' ] && [ "${ARGUMENT_TELEGRAM}" = '1' ]; then
        TELEGRAM_MESSAGE="$(printf "<b>hostname:</b>                  <code>%s</code>\\n<b>disk:</b>                              <code>%s (%s%%) / %s</code>" "${HOSTNAME}" "${ROOT_PARTITION_USED_VIEW}" "${ROOT_PARTITION_USED_PERCENTAGE}" "${ROOT_PARTITION_SIZE_VIEW}")"
        method_telegram
    fi
    exit 0
}

feature_network() {
    gather_information_server

    if [ "${ARGUMENT_NETWORK}" = '1' ] && [ "${ARGUMENT_CLI}" = '1' ]; then
        printf 'serverbot: error: feature network is not implemented\n'
    fi
    if [ "${ARGUMENT_NETWORK}" = '1' ] && [ "${ARGUMENT_LOGGER}" = '1' ]; then
        method_logger 'error: feature network is not implemented'
    fi
    if [ "${ARGUMENT_NETWORK}" = '1' ] && [ "${ARGUMENT_TELEGRAM}" = '1' ]; then
        TELEGRAM_MESSAGE="$(printf "<b>hostname:</b>            <code>%s</code>\\n<b>error:</b>                      <code>serverbot: feature network not implemented</code>" "${HOSTNAME}")"
        method_telegram
    fi
    exit 0
}

feature_alert() {
    gather_information_server
    gather_metrics_cpu
    gather_metrics_memory
    gather_metrics_disk
    gather_temperature_cpu

    if [ "${ARGUMENT_ALERT}" = '1' ] && [ "${ARGUMENT_CLI}" = '1' ]; then
        if [ "${CPU_LOAD_PERCENTAGE}" -gt "${CONFIG_THRESHOLD_LOAD}" ]; then
            printf "%b[%b%b!%b%b]%b current server load of %b%s%b%% exceeds the threshold of %b%s%b%%\n" "${BOLD}" "${NC}" "${LRED}" "${NC}" "${BOLD}" "${NC}" "${LRED}" "${CPU_LOAD_PERCENTAGE}" "${NC}" "${YELLOW}" "${CONFIG_THRESHOLD_LOAD}" "${NC}"
        else
            printf "%b[%b%bi%b%b]%b current server load of %b%s%b%% does not exceed the threshold of %b%s%b%%\n" "${BOLD}" "${NC}" "${LGREEN}" "${NC}" "${BOLD}" "${NC}" "${LGREEN}" "${CPU_LOAD_PERCENTAGE_15MIN}" "${NC}" "${YELLOW}" "${CONFIG_THRESHOLD_LOAD}" "${NC}"
        fi
        if [ "${MEMORY_USED_NOARC_PERCENTAGE}" -gt "${CONFIG_THRESHOLD_MEMORY}" ]; then
            printf "%b[%b%b!%b%b]%b current memory usage of %b%s%b%% exceeds the threshold of %b%s%b%%\n" "${BOLD}" "${NC}" "${LRED}" "${NC}" "${BOLD}" "${NC}" "${LRED}" "${MEMORY_USED_NOARC_PERCENTAGE}" "${NC}" "${YELLOW}" "${CONFIG_THRESHOLD_MEMORY}" "${NC}"
        else
            printf "%b[%b%bi%b%b]%b current memory usage of %b%s%b%% does not exceed the threshold of %b%s%b%%\n" "${BOLD}" "${NC}" "${LGREEN}" "${NC}" "${BOLD}" "${NC}" "${LGREEN}" "${MEMORY_USED_NOARC_PERCENTAGE}" "${NC}" "${YELLOW}" "${CONFIG_THRESHOLD_MEMORY}" "${NC}"
        fi
        if [ "${ROOT_PARTITION_USED_PERCENTAGE}" -gt "${CONFIG_THRESHOLD_DISK}" ]; then
            printf "%b[%b%b!%b%b]%b current disk usage of %b%s%b%% exceeds the threshold of %b%s%b%%\n" "${BOLD}" "${NC}" "${LRED}" "${NC}" "${BOLD}" "${NC}" "${LRED}" "${ROOT_PARTITION_USED_PERCENTAGE}" "${NC}" "${YELLOW}" "${CONFIG_THRESHOLD_DISK}" "${NC}"
        else
            printf "%b[%b%bi%b%b]%b current disk usage of %b%s%b%% does not exceed the threshold of %b%s%b%%\n" "${BOLD}" "${NC}" "${LGREEN}" "${NC}" "${BOLD}" "${NC}" "${LGREEN}" "${ROOT_PARTITION_USED_PERCENTAGE}" "${NC}" "${YELLOW}" "${CONFIG_THRESHOLD_DISK}" "${NC}"
        fi
        if ! [ "${DISABLE_ALERT_CPUTEMP}" = '1' ]; then
            if [ "${CPU_TEMPERATURE}" -gt "${CONFIG_THRESHOLD_CPUTEMP}" ]; then
                printf "%b[%b%b!%b%b]%b current CPU temperature of %b%s%bC exceeds the threshold of%b %b%s%bC\n" "${BOLD}" "${NC}" "${LRED}" "${NC}" "${BOLD}" "${NC}" "${LRED}" "${CPU_TEMPERATURE}" "${NC}" "${YELLOW}" "${CONFIG_THRESHOLD_CPUTEMP}" "${NC}"
            else
                printf "%b[%b%bi%b%b]%b current CPU temperature of %b%s%bC does not exceed the threshold of %b%s%bC\n" "${BOLD}" "${NC}" "${LGREEN}" "${NC}" "${BOLD}" "${NC}" "${LGREEN}" "${CPU_TEMPERATURE}" "${NC}" "${YELLOW}" "${CONFIG_THRESHOLD_CPUTEMP}" "${NC}"
            fi
        fi
    fi
    if [ "${ARGUMENT_ALERT}" = '1' ] && [ "${ARGUMENT_LOGGER}" = '1' ]; then
        if [ "${CPU_LOAD_PERCENTAGE}" -gt "${CONFIG_THRESHOLD_LOAD}" ]; then
            method_logger "current server load of ${CPU_LOAD_PERCENTAGE} exceeds the threshold of ${CONFIG_THRESHOLD_LOAD}"
        fi
        if [ "${MEMORY_USED_NOARC_PERCENTAGE}" -gt "${CONFIG_THRESHOLD_MEMORY}" ]; then
            method_logger "current memory usage of ${MEMORY_USED_NOARC_PERCENTAGE} exceeds the threshold of ${CONFIG_THRESHOLD_MEMORY}"
        fi
        if [ "${ROOT_PARTITION_USED_PERCENTAGE}" -gt "${CONFIG_THRESHOLD_DISK}" ]; then
            method_logger "current disk usage of ${ROOT_PARTITION_USED_PERCENTAGE} exceeds the threshold of ${CONFIG_THRESHOLD_DISK}"
        fi
        if ! [ "${DISABLE_ALERT_CPUTEMP}" = '1' ]; then
            if [ "${CPU_TEMPERATURE}" -gt "${CONFIG_THRESHOLD_CPUTEMP}" ]; then
                method_logger "current CPU temperature of ${CPU_TEMPERATURE}C exceeds the threshold of ${CONFIG_THRESHOLD_CPUTEMP}C"
            fi
        fi
    fi
    if [ "${ARGUMENT_ALERT}" = '1' ] && [ "${ARGUMENT_TELEGRAM}" = '1' ]; then
        if [ "${CPU_LOAD_PERCENTAGE}" -gt "${CONFIG_THRESHOLD_LOAD}" ]; then
            TELEGRAM_MESSAGE="$(echo -e "%e2%9a%a0 <b>[ALERT]</b> <code>${HOSTNAME}</code>\\nCurrent server load (${CPU_LOAD_PERCENTAGE}%) exceeds the threshold (${CONFIG_THRESHOLD_LOAD}%).")"
            method_telegram
        fi
        if [ "${MEMORY_USED_NOARC_PERCENTAGE}" -gt "${CONFIG_THRESHOLD_MEMORY}" ]; then
            TELEGRAM_MESSAGE="$(echo -e "%e2%9a%a0 <b>[ALERT]</b> <code>${HOSTNAME}</code>\\nCurrent memory usage (${MEMORY_USED_NOARC_PERCENTAGE}%) exceeds the threshold (${CONFIG_THRESHOLD_MEMORY}%).")"
            method_telegram
        fi
        if [ "${ROOT_PARTITION_USED_PERCENTAGE}" -gt "${CONFIG_THRESHOLD_DISK}" ]; then
            TELEGRAM_MESSAGE="$(echo -e "%e2%9a%a0 <b>[ALERT]</b> <code>${HOSTNAME}</code>\\nCurrent disk usage (${ROOT_PARTITION_USED_PERCENTAGE}%) exceeds the threshold (${CONFIG_THRESHOLD_DISK}%).")"
            method_telegram
        fi
        if ! [ "${DISABLE_ALERT_CPUTEMP}" = '1' ]; then
            if [ "${CPU_TEMPERATURE}" -gt "${CONFIG_THRESHOLD_CPUTEMP}" ]; then
            TELEGRAM_MESSAGE="$(echo -e "%e2%9a%a0 <b>[ALERT]</b> <code>${HOSTNAME}</code>\\nCurrent CPU temperature (${CPU_TEMPERATURE}C) exceeds the threshold (${CONFIG_THRESHOLD_CPUTEMP}C).")"
            method_telegram
            fi
        fi
    fi
    exit 0
}

feature_baseupdates() {
    gather_information_server
    gather_updates_base

    if [ "${ARGUMENT_BASEUPDATES}" = '1' ] && [ "${ARGUMENT_CLI}" = '1' ]; then
        if [ "${UPDATES_BASE}" = '1' ]; then
            printf 'Pending FreeBSD base system updates available.\n'
        elif [ "${UPDATES_BASE}" = '0' ]; then
            printf 'No pending FreeBSD base system updates available.\n'
        fi
    fi
    if [ "${ARGUMENT_BASEUPDATES}" = '1' ] && [ "${ARGUMENT_LOGGER}" = '1' ]; then
        if [ "${UPDATES_BASE}" = '1' ]; then
            method_logger 'Pending FreeBSD base system updates available.'
        elif [ "${UPDATES_BASE}" = '0' ]; then
            method_logger 'Pending FreeBSD base system updates available.'
        fi
    fi
    if [ "${ARGUMENT_BASEUPDATES}" = '1' ] && [ "${ARGUMENT_TELEGRAM}" = '1' ]; then
        if [ "${UPDATES_BASE}" = '1' ]; then
            TELEGRAM_MESSAGE="$(printf "<b>Pending FreeBSD base system updates available on %s.</b>" "${HOSTNAME}")"
            method_telegram
        fi
    fi
    exit 0
}

feature_pkgupdates() {
    gather_information_server
    gather_updates_pkg

    if [ "${ARGUMENT_PKGUPDATES}" = '1' ] && [ "${ARGUMENT_CLI}" = '1' ]; then
        if [ -z "${UPDATES_PKG}" ]; then
            printf 'No pending package updates available.\n'
        else
            printf "Pending package updates available:\n%s\n" "${UPDATES_PKG}"
        fi
    fi
    if [ "${ARGUMENT_PKGUPDATES}" = '1' ] && [ "${ARGUMENT_LOGGER}" = '1' ]; then
        if [ -z "${UPDATES_PKG}" ]; then
            method_logger 'No pending package updates available.'
        else
            method_logger "Pending package updates are available: ${UPDATES_PKG}"
        fi
    fi
    if [ "${ARGUMENT_PKGUPDATES}" = '1' ] && [ "${ARGUMENT_TELEGRAM}" = '1' ]; then
        if [ -n "${UPDATES_PKG}" ]; then
            TELEGRAM_MESSAGE="$(printf "<b>Package updates available on %s</b>:\\n<code>%s</code>" "${HOSTNAME}" "${UPDATES_PKG}")"
            method_telegram
        fi
    fi
    exit 0
}

feature_pkgaudit() {
    gather_information_server
    gather_audit_pkg

    if [ "${ARGUMENT_PKGAUDIT}" = '1' ] && [ "${ARGUMENT_CLI}" = '1' ]; then
        if [ -z "${AUDIT_PKG}" ]; then
            printf 'No known package vulnerabilities to report.\n'
        else
            printf "Packages contain known vulnerabilities:\n%s\n" "${AUDIT_PKG}"
        fi
    fi
    if [ "${ARGUMENT_PKGAUDIT}" = '1' ] && [ "${ARGUMENT_LOGGER}" = '1' ]; then
        if [ -z "${AUDIT_PKG}" ]; then
            method_logger 'No known package vulnerabilities to report.'
        else
            method_logger "Packages contain known vulnerabilities: ${AUDIT_PKG}"
        fi
    fi
    if [ "${ARGUMENT_PKGAUDIT}" = '1' ] && [ "${ARGUMENT_TELEGRAM}" = '1' ]; then
        if [ -n "${AUDIT_PKG}" ]; then
            TELEGRAM_MESSAGE="$(printf "<b>Packages on %s contain vulnerabilities</b>:\\n<code>%s</code>" "${HOSTNAME}" "${AUDIT_PKG}")"
            method_telegram
        fi
    fi
    exit 0
}

feature_pkgchecksum() {
    gather_information_server
    gather_checksum_pkg

    if [ "${ARGUMENT_PKGCHECKSUM}" = '1' ] && [ "${ARGUMENT_CLI}" = '1' ]; then
        if [ -z "${CHECKSUM_PKG}" ]; then
            printf 'No packages contain invalid checksums.\n'
        else
            printf "Packages contain invalid checksums:\n%s\n" "${CHECKSUM_PKG}"
        fi
    fi
    if [ "${ARGUMENT_PKGCHECKSUM}" = '1' ] && [ "${ARGUMENT_LOGGER}" = '1' ]; then
        if [ -z "${CHECKSUM_PKG}" ]; then
            method_logger 'No packages contain invalid checksums.'
        else
            method_logger "Packages contain invalid checksums: ${CHECKSUM_PKG}"
        fi
    fi
    if [ "${ARGUMENT_PKGCHECKSUM}" = '1' ] && [ "${ARGUMENT_TELEGRAM}" = '1' ]; then
        if [ -n "${CHECKSUM_PKG}" ]; then
            TELEGRAM_MESSAGE="$(printf "<b>Packages on %s contain invalid checksums</b>:\\n<code>%s</code>" "${HOSTNAME}" "${CHECKSUM_PKG}")"
            method_telegram
        fi
    fi
    exit 0
}

####################################################################################################
# METHOD FUNCTIONS
####################################################################################################

method_logger() {
    logger -t serverbot "${1}"
}

method_telegram() {
    requirement_curl

    if [ "${METHOD_TELEGRAM}" = '1' ]; then
        TELEGRAM_URL="https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage"

        # create payload for Telegram
        TELEGRAM_PAYLOAD="chat_id=${TELEGRAM_CHAT}&text=${TELEGRAM_MESSAGE}&parse_mode=HTML&disable_web_page_preview=true"

        # sent payload to Telegram API and exit
        "${CURL}" --silent --max-time 10 --retry 5 --retry-delay 2 --retry-max-time 10 -d "${TELEGRAM_PAYLOAD}" "${TELEGRAM_URL}" > /dev/null 2>&1 &
    else
        program_error 'telegram not configured'
    fi
}

####################################################################################################
# MAIN FUNCTIONS
####################################################################################################

serverbot_main() {
    requirement_os
    serverbot_argument_validate

    # default to method CLI if no method is used
    if [ "${ARGUMENT_METHODS_COMBINED}" = '0' ]; then
        ARGUMENT_CLI='1'
    fi
    # direct serverbot to the right feature function
    if [ "${ARGUMENT_BASIC}" = '1' ]; then
        feature_basic
    elif [ "${ARGUMENT_SUMMARY}" = '1' ]; then
        feature_summary
    elif [ "${ARGUMENT_OVERVIEW}" = '1' ]; then
        feature_overview
    elif [ "${ARGUMENT_UPTIME}" = '1' ]; then
        feature_uptime
    elif [ "${ARGUMENT_CPU}" = '1' ]; then
        feature_cpu
    elif [ "${ARGUMENT_MEMORY}" = '1' ]; then
        feature_memory
    elif [ "${ARGUMENT_MEMORYTREE}" = '1' ]; then
        feature_memorytree
    elif [ "${ARGUMENT_DISK}" = '1' ]; then
        feature_disk
    elif [ "${ARGUMENT_NETWORK}" = '1' ]; then
        feature_network
    elif [ "${ARGUMENT_ALERT}" = '1' ]; then
        feature_alert
    elif [ "${ARGUMENT_BASEUPDATES}" = '1' ]; then
        feature_baseupdates
    elif [ "${ARGUMENT_PKGUPDATES}" = '1' ]; then
        feature_pkgupdates
    elif [ "${ARGUMENT_PKGAUDIT}" = '1' ]; then
        feature_pkgaudit
    elif [ "${ARGUMENT_PKGCHECKSUM}" = '1' ]; then
        feature_pkgchecksum
    elif [ "${ARGUMENT_CRON}" = '1' ]; then
        option_cron
    elif [ "${ARGUMENT_VERSION}" = '1' ]; then
        option_version
    elif [ "${ARGUMENT_HELP}" = '1' ]; then
        option_help
    # feature overview with method cli is shown when no arguments are given
    else
        ARGUMENT_OVERVIEW='1'
        ARGUMENT_CLI='1'
        feature_overview
    fi
}

####################################################################################################
# CALL MAIN FUNCTIONS
####################################################################################################

serverbot_main
